:imagesdir: ./images/algebra
:subs: non

== The Algebra

=== The Obj Magma

.Monoids
****
A https://en.wikipedia.org/wiki/Monoid[monoid] is a structure of the form \$(A,\cdot,\mathbf{1})\$, where \$A\$ is the carrier set closed under the associative binary operator \$\cdot: A \times A \rightarrow A\$ with \$\mathbf{1} \in A\$ being the https://en.wikipedia.org/wiki/Identity_element[identity] such that for every \$a,b,c \in A\$, \$(a \cdot b) \cdot c = a \cdot (b \cdot c)\$ and \$a \cdot \mathbf{1} = \mathbf{1} \cdot a = a\$.
****

A https://en.wikipedia.org/wiki/Magma_(algebra)[magma] is a partially https://en.wikipedia.org/wiki/Associative_property[associative] algebraic structure with a single https://en.wikipedia.org/wiki/Binary_operation[binary operator].
The `obj` magma is defined \[
(\texttt{obj},=>,\underline{\mathbf{1}}), \]
where `obj` is the set of all quantified mm-ADT objects, \$ =>: \tt{obj} \times \tt{obj} \rightarrow \tt{obj}\$ the binary _apply_ operator, and \$\underline{\mathbf{1}}\$ the https://en.wikipedia.org/wiki/Identity_element[identity element].
Given that an `obj` is either exclusively a type or a value, \$=>\$ supports four https://en.wikipedia.org/wiki/Argument_of_a_function[argument] combinations.

[cols="1,1,2,5"]
|===
| arguments    | name                | equation | mmlang example

| value/value  | push                | \$a_{q_0} => b_{q_1} \mapsto b_{q_0 \ast q_1}\$
a|
[exec]
----
'a'{2} => 'b'{6}
----
{blank}
| value/type    | evaluation         | \$a_{q_0} => b_{q_1} \mapsto b(a)_{q_0 \ast q_1}\$
a|
[exec]
----
'a'{2} => str{2}[plus,'b']{6}
----
{blank}
| type/value  |  push                |\$a_{q_0} => b_{q_1} \mapsto b_{q_0 \ast q_1}\$
a|
[exec]
----
str[plus,'a']{2} => 'b'{6}
----
{blank}
| type/type  |  compilation          | \$a_{q_0} => b_{q_1} \mapsto b(a)_{q_0 \ast q_1}\$
a|
[exec]
----
str[plus,'a']{2} => str{2}[plus,'b']{6}
----
{blank}
|===

For the two \$x => \tt{type}\$ argument patterns, the type https://en.wikipedia.org/wiki/Semigroup_action[acts] on \$x\$ -- i.e., \$\tt{type}(x)\$.
The \$=>\$ operator is a https://en.wikipedia.org/wiki/Higher-order_function[higher order function], where the semantics of the application are in the type's definition.
For instance, in the expression `'a' \=> str[plus,'b']`, `'a'` is being applied to `str[plus,'b']`, and only when `str[plus,'b']` acts on `'a'` is \$=>\$ full defined.
Thus, the complexity of the `obj` magma lies in the elements of its carrier set -- in particular, in the virtual machine's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (`inst`) which, by definition, is expressive enough to https://en.wikipedia.org/wiki/Embedding[embed] the fundamental `obj` stream ring, the `inst` monoid, and the type ringoid algebras.

NOTE: The \$=>\$ (apply) operator is a monoidal generalization of https://en.wikipedia.org/wiki/Scalar_multiplication[scalar multiplication] that respects the axioms of a ring theoretic https://en.wikipedia.org/wiki/Bimodule[bimodule].
In this interpretation, \$=>\$ is a third binary operator of the `obj` stream ring.
A complete formalization of the `obj` https://en.wikipedia.org/wiki/Vector_space[vector space] is forthcoming.

The example below demonstrates the value/type argument pattern via the `int[plus,int[mult,2]]` right action on `5`.
Note that within the initial action, a cascade of further actions take place highlighting the value/type and value/value argument patterns.

[cols="1,2"]
|===
| \[
\begin{split}
5 =>&\; \texttt{int}[\texttt{plus\},\texttt{int}[\texttt{mult},2]]        \\
5 =>&\; \texttt{int}[\texttt{plus\},5=>\texttt{int}[\texttt{mult},2]]     \\
5 =>&\; \texttt{int}[\texttt{plus\},5=>\texttt{int}[\texttt{mult},5=>2]]  \\
5 =>&\; \texttt{int}[\texttt{plus\},5=>\texttt{int}[\texttt{mult},2]]     \\
5 =>&\; \texttt{int}[\texttt{plus\},10]                                   \\
5 =>&\; 15                                                                \\
15\;\;\,&
\end{split}
\]
a|
[exec]
----
5 => int[plus,int[mult,2]]
5 => int[plus,int[mult,2]][explain]
5 => int[plus,int[mult,2]][path]
----
{blank}
|===

=== The Inst Monoid

.Free Algebra
****
A https://en.wikipedia.org/wiki/Magma_(algebra)[magma algebra] is defined by a carrier set \$A\$ along with a https://en.wikipedia.org/wiki/Binary_operation[binary operator] \$\cdot: A \times A \to A\$ that combines and two \$A\$-elements into one (\$a \cdot b \mapsto c\$), and a set of https://en.wikipedia.org/wiki/Axiom[axioms] denoting "link:https://en.wikipedia.org/wiki/Hard_coding[hardcoded]" \$A\$-related equations that a structure must obey should it be an instance of the https://en.wikipedia.org/wiki/Algebraic_structure[algebra] \$(A,\cdot)\$.

With the more concise representation of \$ab \equiv a \cdot b\$, if \$a,b,c \in A\$, and \$ab = c\$, then should there be another element \$d \in A\$ such that \$ad = c\$, it is unknown whether \$ab\$ or \$ad\$ was used to derive \$c\$.
Assuming the general case that all elements do not have unique two element https://en.wikipedia.org/wiki/Factorization[factors] in \$A\$, then the binary operator \$\cdot\$ is an irreversible, https://en.wikipedia.org/wiki/Lossy_compression[lossy] operation.

A https://en.wikipedia.org/wiki/Sequence[sequence] of \$\cdot\$-compositions can be stored in a https://en.wikipedia.org/wiki/List_(abstract_data_type)[list].
Such structures are \$A\$-"link:https://en.wikipedia.org/wiki/Computer_program[programs]" that can be executed against _any_ \$A\$-machine.
If \$a,b,c,d,e \in A\$, then an example \$A\$-program is \[
aabbbcadebdcaecadeeeeabccbcaabb.
\]
While the individual elements of the \$A\$-program are in \$A\$, the program as a whole is a _single_ element in \$A^\ast\$.
\$A^\ast\$ is the infinite set of all possible \$A\$-element sequences of arbitrary length called the https://en.wikipedia.org/wiki/Kleene_star[Kleene closure] over \$A\$.
From this vantage point, the elements of \$A\$ are called *letters* and the elements of \$A^\ast\$ are called *words*.
The set \$A^\ast\$ is the carrier set of another algebra \$(A^\ast,\circ)\$, where \$\circ: A^\ast \times A^\ast \to A^\ast\$ concatenates two words into a single word (i.e. list concatenation).
This algebra is used to "link:https://en.wikipedia.org/wiki/Programmer[code]" \$A\$-programs.
In the world of https://en.wikipedia.org/wiki/Abstract_algebra[abstract algebra], this new \$(A^\ast,\circ)\$ algebra is called the https://en.wikipedia.org/wiki/Free_algebra[free algebra] over \$A\$.

A word in \$A^\ast\$ can be reduced to a single letter in \$A\$ via a https://en.wikipedia.org/wiki/Algebra_homomorphism[homomorphism] that relates \$(A^\ast,\circ)\$ and \$(A,\cdot)\$ denoted \$\eta: A^\ast \to \A\$ . Thus, given any \$A^\ast\$-program, \$\eta\$ "link:https://en.wikipedia.org/wiki/Execution_(computing)[executes]" the program on some \$A\$-machine.
If the \$\eta\$-mapping is preserved, then the answer to whether \$c\$ was arrived at via \$ab\$ or \$ad\$ is known. mm-ADT preserves such mappings in a structure known as the `obj` graph. mm-ADT's link:https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)[graph]-encoding of a free algebraic https://en.wikipedia.org/wiki/Digital_footprint[trace] is the foundation of numerous mm-ADT capabilities including https://en.wikipedia.org/wiki/Abstract_interpretation[abstract interpretation], https://en.wikipedia.org/wiki/State_(computer_science)[program state], https://en.wikipedia.org/wiki/Metaprogramming[metaprogramming], and https://en.wikipedia.org/wiki/Reversible_computing[reversible computing].
****

The mm-ADT virtual machine's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (ISA) is denoted `inst` \$\subset\$ `obj`.
In `mmlang`, an `inst` is defined by the grammar fragment

[.text-center]
`inst  ::= '[' op(','obj)* ']' q?`,

where `op` is an https://en.wikipedia.org/wiki/Opcode[opcode] from a predefined set of character string.
Example opcodes include `plus`, `mult`, `branch`, `is`, `gt`, `lt`, etc.
An mm-ADT program is a https://en.wikipedia.org/wiki/Assembly_language[sequence of instructions] commonly known as https://en.wikipedia.org/wiki/Bytecode[bytecode].
While an mm-ADT program can be realized as a ring of types and values being added and multiplied, there is a https://en.wikipedia.org/wiki/Full_and_faithful_functors[faithful embedding] of this richer ring structure into a https://en.wikipedia.org/wiki/Syntactic_monoid[syntactic monoid] called the `inst` monoid defined as \[
(\texttt{inst}^\ast,\circ,\emptyset), \]
where \$\circ:\tt{i\nst}^\ast \times \tt{i\nst}^\ast \to \tt{i\nst}^\ast\$ concatenates `inst` sequences and \$\emptyset\$ is the https://en.wikipedia.org/wiki/Empty_set[empty set] behaving as the identity element.
An mm-ADT program is a type.
In order to generate a type from a word of the free `inst` monoid, there exists a https://en.wikipedia.org/wiki/Homomorphism[homomorphism] (https://en.wikipedia.org/wiki/Assembly_language#Assembler[assembler]) from the `inst` monoid to the `obj` magma \$(\tt{obj},\Rightarrow,\underline{\mathbf{1}})\$.

.Rosetta Stone
[cols="1,2,3",width=35,float=right]
|===
| algebra   | machine        | mm-ADT

| `inst`    | ISA            | `inst`
| `inst^*^` | bytecode       | `inst` `poly`
| \$\eta\$  | assembler      | type induction
| `type`    | program        | type
|===

.`inst` monoid to `obj` magma homomorphism
\[
\begin{split}
& \eta: \texttt{inst}^\ast &\to \texttt{type} \\\\ & \eta(\emptyset) &= \underline{\mathbf{1}} \\ & \eta(a \circ b) &= a \Rightarrow b \\\\ & \eta(x) &= \prod_{i \lt |x|}^{\Rightarrow} x_i \\ & &= x_0 \Rightarrow x_1 \Rightarrow \ldots \Rightarrow x_{{|x|}-1} \end{split}
\]

image::start-ctypes.png[float="right",width=315]

For example, if \$abcde \in \tt{i\nst}^\ast\$, then \[
\eta(abcde) \mapsto a => b => c => d => e.
\]

[exec]
----
[start,int][plus,1][mult,2]
[start,int]=>[plus,1]=>[mult,2]
----

'''

=== The Stream Ringoid

.Stream Ring Theory
****

image:biproduct.svg[float=right,width=250]

https://zenodo.org/record/2565243[Stream ring theory] studies a particular type of algebraic https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] constructed from a https://en.wikipedia.org/wiki/Product_ring[direct product] of a *function* https://en.wikipedia.org/wiki/Semiring[semiring] and *coefficient* ring.
Along with the standard https://en.wikipedia.org/wiki/Ring_(mathematics)#Definition[ring axioms], the theory requires that every stream ring uphold five additional https://en.wikipedia.org/wiki/Axiom[axioms] regarding https://en.wikipedia.org/wiki/Coefficient[coefficient] dynamics.
Categorically, every stream ring forms an https://en.wikipedia.org/wiki/Additive_category[additive category] with https://en.wikipedia.org/wiki/Biproduct[biproducts].
A biproduct has both projection (https://en.wikipedia.org/wiki/Product_(category_theory)[product]) and injection (https://en.wikipedia.org/wiki/Coproduct[coproduct]) morphisms that capture the splitting and merging of streams.
Along with the _atemporal stream theorem_ derived from the stream ring axioms, biproduct streams have practical significance in https://en.wikipedia.org/wiki/Asynchronous_system[asynchronous] distributed computing environments that primarily enjoy https://en.wikipedia.org/wiki/Embarrassingly_parallel[embarrassingly parallel] processing, but where, at certain space and time https://en.wikipedia.org/wiki/Bulk_synchronous_parallel[synchronization] points, data needs to be co-located.

mm-ADT adopts the algebra of stream ring theory, but uses the term *instruction* for _function_ and *quantifier* for _coefficient_.
Moreover, mm-ADT extends stream ring theory with an https://en.wikipedia.org/wiki/Inductive_type[inductive], https://en.wikipedia.org/wiki/Dependent_type[dependent] https://en.wikipedia.org/wiki/Type_theory[type theory] based on a https://en.wikipedia.org/wiki/Many-sorted_logic[multi-sorted] stream ring with https://en.wikipedia.org/wiki/Interval_(mathematics)[interval] quantifiers called the *type ringoid*.
****

The *`obj` stream ringoid* is the https://en.wikipedia.org/wiki/Ring_theory[algebraic ring]
\[
(\texttt{obj},[,],[;],\;\underline{\mathbf{0}}\;\underline{\mathbf{1}}), \]

where

image::type-value-illustration.svg[float=right,width=525]

* `obj` is the set of all quantified objects,
* `[,]` the additive _parallel branch_ operator,
* `[;]` the multiplicative _serial chain_ operator,
* \$\underline{\mathbf{0}}\$ the additive identity, and
* \$\underline{\mathbf{1}}\$ the multiplicative identity.

'''

Given \$\tt{obj} = \tt{type} + \tt{value}\$ and the suggestive illustration above, the stream ringoid's binary operators

* \$,;: \tt{type} \times \tt{type} \to \tt{type}\$ generate functions graph (*program compilation*) and,
* \$,;: \tt{value} \times \tt{type} \to \tt{value}\$ _stream_ values through the type structure (*program evaluation*).

Along with the standard https://en.wikipedia.org/wiki/Ring_(mathematics)#Definition[ring axioms] (save operator https://en.wikipedia.org/wiki/Closure_(mathematics)[closure]), the `obj` stream ring respects the five additional axioms of *stream ring theory*.
The following tables provide a consolidated summary of the ring axioms, stream ring axioms and their realization in mm-ADT via examples in `mmlang` using both `obj` *values* and *types*.

NOTE: The `mmlang` examples are rife with https://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugars].
The term `\_{0}` is \$\underline{\mathbf{0}}\$, `_{1}` is \$\underline{\mathbf{1}}\$, `[a;b;c]` denotes `[branch,(a;b;c)]` and `+{q}n` denotes `[plus,n]{q}`.
Finally, while `[,]` and `[;]` are defined as binary operators, due to the link:https://en.wikipedia.org/wiki/Associative_property[associativity] axioms of the respective additive group and multiplicative monoid of a ring, `[,]` and `[;]` are effectively \$n\$-ary operators and will be used as such in examples to follow.

==== Ring Axioms

https://en.wikipedia.org/wiki/Axiom[Axioms] are the "link:https://en.wikipedia.org/wiki/Hard_coding[hardcoded]" equations of a system.
Regardless of any other behaviors the system may express, if the system always respects the ring axioms, then the system is (in part) a ring.

[cols="2,2,7,9"]
|===
^|  axiom ^| equation  ^| mmlang values ^| mmlang types

4.+^h| Additive Abelian Group -- \$(\tt{obj},[,],\underline{\mathbf{0}})\$

| Additive associativity
| \[\begin{split}
&(a+b)\+c \\
=& a+(b+c)
\end{split}\]
a|
[exec,prompt="mm> "]
----
[['a','b'],'c']
['a',['b','c']]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[[id],[id]],[id]]
str[[id],[[id],[id]]]
----
{blank}
| Additive commutativity
| \[\begin{split}
&a+b \\
=& b+a
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a','b']
['b','a']
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id]{2},[id]{3}]
str[[id]{3},[id]{2}]
----
{blank}
| Additive identity
| \[a+\mathbf{0} = a\]
a|
[exec,prompt="mm> "]
----
['a',_{0}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id],_{0}]
----
{blank}
| Additive inverse
| \[a + ({-a}) = \mathbf{0}\]
a|
[exec,prompt="mm> "]
----
['a','a'{-1}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id],[id]{-1}]
----
{blank}

4.+^h| Multiplicative Monoid -- \$(\tt{obj},[;],\underline{\mathbf{1}})\$
| Multiplicative associativity
| \[\begin{split}
&(a \cdot b) \cdot c \\
=& a \cdot (b \cdot c)
\end{split}\]
a|
[exec,prompt="mm> "]
----
[['a';'b'];'c']
['a';['b';'c']]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[[id];[id]];[id]]
str[[id];[[id];[id]]]
----
{blank}
| Multiplicative identity
| \[a \cdot \mathbf{1} = a\]
a|
[exec,prompt="mm> "]
----
['a';_{1}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id];_{1}]
----
{blank}

4.+^h| Ring with Unity -- \$(\tt{obj},[,],[;],\underline{\mathbf{0}},\underline{\mathbf{1}})\$

| Left distributivity
| \[\begin{split}
&a \cdot (b + c) \\
=& ab + ac
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a';['b','c']]
[['a';'b'],['a';'c']]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id];[[id],[id]]]
str[[[id];[id]],[[id];[id]]]
----
{blank}
| Right distributivity
| \[\begin{split}
&(a+b) \cdot c \\
=& ac + bc
\end{split}\]
a|
[exec,prompt="mm> "]
----
[['a','b'];'c']
[['a';'c'],['b';'c']]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[[id],[id]];[id]]
str[[[id];[id]],[[id];[id]]]
----
{blank}
|===

===== Ring Theorems

The axioms of a theory entail its https://en.wikipedia.org/wiki/Theorem[theorems].
Stated in reverse, theorems are the derivations of an https://en.wikipedia.org/wiki/Axiomatic_system[axiomatic system].
Once a system is determined to be a ring, then all the theorems that have been proved about rings in general are also true for that system.

[cols="2,2,7,9"]
|===
^| theorem ^| equation  ^| mmlang values ^| mmlang types

4.+^h| Ring with Unity -- \$(\tt{obj},[,],[;],\underline{\mathbf{0}},\underline{\mathbf{1}})\$

| Additive factoring
| \[\begin{split}
&a + b = a + c \\
=>& b = c
\end{split}\]
a|
{blank}
a|
{blank}
| Unique factoring
|  \[\begin{split}
&a + b = \mathbf{0} \\
=>& a = -b \\
=>& b = -a
\end{split}\]
a|
{blank}
a|
{blank}
| Inverse distributivity
| \[\begin{split}
&-(a+b) \\
=& (-a) + (-b)
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a','b']{-1}
['a'{-1},'b'{-1}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id],[id]]{-1}
str[[id]{-1},[id]{-1}]
----
{blank}
| Inverse distributivity
| \[-(-a) = a\]
a|
[exec,prompt="mm> "]
----
['a'{-1}]{-1}
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id]{-1}]{-1}
----
{blank}
| Annihilator
| \[\begin{split}
&a*\mathbf{0} \\
=& \mathbf{0} \\
=& \mathbf{0}*a
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a';_{0}]
[_{0};'a']
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id];_{0}]
str[_{0};[id]]
----
{blank}
| Factoring
| \[\begin{split}
&a * (-b) \\
=& -a * b \\
=& -(a*b)
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a';'b'{-1}]
['a'{-1};'b']
['a';'b']{-1}
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id];[id]{-1}]
str[[id]{-1};[id]]
str[[id];[id]]{-1}
----
{blank}
| Factoring
|  \[\begin{split}
&(-a) * (-b) \\
=& a * b
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a'{-1};'b'{-1}]
['a';'b']
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id]{-1};[id]{-1}]
str[[id];[id]]
----
{blank}
|===

==== Stream Ring Axioms

.Ringoids
****
An algebraic https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] \$(A,\+,\ast,\mathbf{0},\mathbf{1})\$ is composed of an additive abelian group \$(A,\+,\mathbf{0})\$ and a multiplicative monoid \$(A,\ast,\mathbf{1})\$ that share the same carrier set \$A\$ and whose operators are bound by the axiom of distributivity that requires \[
a \ast (b + c) = ab + ac \\ (a + b) \ast c = ac + bc.
\]
A https://ncatlab.org/nlab/show/Ab-enriched+category[ringoid] generalizes a ring with a multi-sorted carrier \$A = (A_0,A_1,\ldots,A_n)\$ such that the magmas of the binary operators are https://en.wikipedia.org/wiki/Partial_function[partial functions] lacking https://en.wikipedia.org/wiki/Closure_(mathematics)[closure].
In other words, a ringoid is a ring with a type system with the consequence that for any element \$a \in A_i\$ and \$b \in A_j\$, it is not required that \$a + b\$ nor \$a \ast b\$ be defined.
****

image:obj-semiring-orderedring.svg[float=left,width=350]

Stream ring theory studies _quantified objects_.
The quantifiers must be elements of an https://en.wikipedia.org/wiki/Ordered_ring[ordered ring] with unity.
The stream ring axioms are primarily concerned with quantifier equations and their relationship to efficient https://en.wikipedia.org/wiki/Stream_(computing)[stream computing].
The most common quantifier ring is integer pairs (denoting a range) with standard pairwise addition and multiplication, \$(\mathbb{Z} \times \mathbb{Z},+,\ast,(0,0),(1,1))\$.
However, the theory holds as long as the quantifiers respect the ring axioms and, when coupled to an object, they respect the stream ring axioms.

NOTE: The algebra underlying most type theories operate as a https://en.wikipedia.org/wiki/Semiring[semiring(oid)], where the additive component is a https://en.wikipedia.org/wiki/Monoid[monoid] as opposed to an invertible https://en.wikipedia.org/wiki/Group_(mathematics)[group].
In mm-ADT, the elements of the additive component can be inverted by their corresponding _negative type_ (or negative `obj` in general).
Thus, mm-ADT realizes an additive https://en.wikipedia.org/wiki/Groupoid[groupoid], where, for example, the `,-poly` `[int{1},int{-1}]` is `int{0}` which is isomorphic to the initial `obj{0}`.

[cols="2,2,7,9"]
|===
^| axiom   ^| equation    ^| mmlang values ^| mmlang types

| Bulking  | \[\begin{split}
& xa + ya \\
=& (x+y)a
\end{split}\]
a|
[exec,prompt="mm> "]
----
['a'{2},'a'{3}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[id]{2},[id]{3}]
----
{blank}
| Applying  | \$xa \ast yb = (xy)ab\$
a|
[exec,prompt="mm> "]
----
'a'{2}['b'{3}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str{2}[[id]{3}]
----
{blank}
| Splitting  | \[\begin{split}
& xa \ast (yb + zc) \\
=& (xy)ab + (xz)ac
\end{split}\]
a|
[exec,prompt="mm> "]
----
'a'{2}['b'{3},'c'{4}]
['b'{6},'c'{8}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str{2}[[id]{3},[id]{4}]
str[[id]{6},[id]{8}]
----
{blank}
| Merging  | \[\begin{split}
& \((xa) + (yb)) \\
=& (xa + yb)
\end{split}\]
a|
[exec,prompt="mm> "]
----
[['a'{2}],['b'{3}]]
['a'{2},'b'{3}]
----
{blank}
a|
[exec,prompt="mm> "]
----
str[[[id]{2}],[[id]{3}]]
str[[id]{2},[id]{3}]
----
{blank}
| Removing  | \[ (\mathbf{0}a + b) = b \]
a|
[exec,prompt="mm> "]
----
['a'{0},'b']
----
{blank}
a|
[exec,prompt="mm> "]
----
str[_{0},[id]]
----
{blank}
|===

===== Stream Compression

The *bulking*, *merging*, and *removing* axioms are aimed at reducing the amount of data flowing through a stream, while the *splitting* and *applying* axioms maintain quantifier semantics as elements of the _object_ https://en.wikipedia.org/wiki/Semiring[semiring] are operated on.
When only considering the standard ring axioms, the stream

[float=right,width=45]
|===
a|
[exec]
----
['a','a','b','a','b','b','a','a']
['a'{5},'b'{3}]
----
{blank}
|===

\[
[ a,a,b,a,b,b,a,a ]
\]
is https://en.wikipedia.org/wiki/Irreducible_polynomial[irreducible].
However, with the stream ring axioms and \$\mathbb{Z}\$-quantifiers, the above stream is equivalent to \[
[ 5a,3b ], \]
where the abelian group operator `[,]` is https://en.wikipedia.org/wiki/Commutative_property[commutative] -- i.e., \$[ 5a,3b ] \equiv [3b,5a]\$.

Stream compression is achieved by removing redundant information in a https://en.wikipedia.org/wiki/Lossless_compression[lossless] manner such that https://en.wikipedia.org/wiki/Enumeration[enumeration] is replaced with quantification.
From a data structure perspective, an unordered https://en.wikipedia.org/wiki/Collection_%28abstract_data_type%29[collection] is converted into a weighted https://en.wikipedia.org/wiki/Multiset[multiset].
Relying on the same axiomatic principle, but reframed in terms of types (programs), the _atemporal stream theorem_ guarantees equivalent outcomes for both https://en.wikipedia.org/wiki/Synchronous_circuit[synchronous] and https://en.wikipedia.org/wiki/Asynchronous_system[asynchronous] execution strategies.

===== Asynchronous Types

The two examples below highlight this time/space entailment, where the former realizes a https://en.wikipedia.org/wiki/Optimizing_compiler[compile time optimization] and the latter a https://en.wikipedia.org/wiki/Program_optimization#Run_time[runtime optimization].

NOTE: Expressions of the form `-<(a,b,c)>-` are decomposed representations of `[a,b,c]`, where `-<(a,b,c)` _splits_, but does not _merge_.

[cols="5,8"]
|===

a|
[exec]
----
5 => int+1
5 => int+1-<(_,_)
5 => int+1-<(*2,*2)
5 => int+1-<(*2,*2)>-
5 => int+1-<(*2,*2)>-+2
----
{blank}
[exec]
----
5 => int+1*{2}2+2
----
{blank}
| image:type-bulk-example.svg[]
a|
[exec]
----
5 => int+1
5 => int+1-<(_,_)
5 => int+1-<(*2,+6)
5 => int+1-<(*2,+6)>-
5 => int+1-<(*2,+6)>-+2
----
{blank}
[exec]
----
5 => int-<(+1*2+2,+1+6+2)
5 => int-<(+1*2+2,+1+6+2)>-
----
{blank}
| image:value-bulk-example.svg[]
|===

As a ring, an mm-ADT `obj` can be multiplied or added to another `obj`.
Multiplication is denoted with `\=>` (`5 \=> int+2`) or simple term juxtaposition (`5+2`).
Addition, on the other hand, is realized by the `[branch]` instruction which has an `mmlang` sugar of `[,]`.
The way in which `obj` addition effects the `obj` graph is important.

[exec]
----
int => int[+4[is>0],*5]+1                                                   //<1>
2 => int[+4[is>0],*5]+1                                                     //<2>
2 => int[+4[is>0],*5]+1[path]                                               //<3>
2 => int[+4[is>0],*5]+1[type]                                               //<4>
----
<1> The `int`-dependent type clones the `int` to the two branches, merges the branch output, and adds `1` (*compilation*).
<2> `2` is propagated through the `int{1,2}\<=int` type (*evalution*).
<3> The path through the `obj` value graph taken by the resultant `objs`.
<4> The type of each resultant value.

The compilation of the `int{1,2}\<=int` type generates the path diagrammed below in the *type subgraph* of the `obj` graph.

image::obj-type-path-example.svg[width=625,align=center]

The evaluation of the type with the input of `2` generates two paths through the *value subgraph* of the `obj` graph -- via _split_ (\$\Delta\$) and _merge_ (\$\nabla\$).
Branching (addition) is one of two fundamental operations in the mm-ADT ring algebra.
It is not manifested as an `inst` in a value's path history.
Likewise, the other fundamental operation, `\=>` (multiplication) has no explicit `inst` and is denoted with juxtaposition in the value path history.
The significance of branching being fundamental in mm-ADT is that individual branches can evaluate in https://en.wikipedia.org/wiki/Embarrassingly_parallel[decoupled], independent manner requiring no https://en.wikipedia.org/wiki/Synchronization_(computer_science)[synchronization] nor explicit https://en.wikipedia.org/wiki/Barrier_%28computer_science%29[coordination] at merge.

image::obj-value-path-example.svg[align=center]

.Process Architectures Sympathetic to the Type Ringoid
================================================================
An `mmlang` expression denotes a *type* (program) that is executed by a processor.
A type is an element of the *type ringoid* algebra.
The type ringoid is not the intended algebra of the language component.
The reason being, languages yield linear structures.
A linear medium is sympathetic to single operator https://en.wikipedia.org/wiki/Magma_(algebra)[magmas] such as https://en.wikipedia.org/wiki/Monoid[monoids] or https://en.wikipedia.org/wiki/Group_(mathematics)[groups].
In order to express addition (branching) in these structures, the parallel branches are serially embedded using the `[,]` syntactic https://en.wikipedia.org/wiki/Kludge#Computer_science[hack].

The *type* elements of the type ringoid are https://en.wikipedia.org/wiki/Three-dimensional_space[three dimensional] structures (where the third dimension captures nesting) and have a more natural embedding in the spatial component of the physical world.
Computationally, types are evaluated by processors across a number of cores of a single machine and/or across a multi-machine compute cluster.
The type ringoid algebra yields types that are sympathetic to a variety of modern processor architectures.

. https://en.wikipedia.org/wiki/Iterator[Iterator]: single threaded, pull-based, lazily evaluated, functionally oriented
. https://en.wikipedia.org/wiki/Reactive_programming[Reactive]: multi-threaded, push-based, lazily evaluated, stream oriented
. https://en.wikipedia.org/wiki/Bulk_synchronous_parallel[Bulk Synchronous Parallel]: cluster, pull-based, eagerly evaluated, pipeline oriented
. https://en.wikipedia.org/wiki/Message_passing[Message-Passing]; cluster/multi-threaded, push-based, lazily evaluated, actor oriented
================================================================

===== Commuting Quantifiers

[cols="7,4"]
|===

| Each of these expressions is equivalent to `obj{0}`. This is demonstrated using the `;-poly` quantifier equation. `2*3*0 = 2*0*4 = 0*3*4`. In general, if there exists a *0*-quantified `obj` in a `obj`  monoid expression, then the result is always `obj{0}`.
<.^a|
[exec]
----
6{2}+{3}1+{0}2
6{2}+{0}1+{4}2
6{0}+{3}1+{4}2
----
{blank}
| All three expression evaluate to the same `9{24}` value. The quantifier ring has a https://en.wikipedia.org/wiki/Commutative_property[commutative] multiplicative monoid such that `2*3*4 = 3*4*2 = 4*2*1`.
<.^a|
[exec]
----
6{2}+{3}1+{4}2
6{3}+{4}1+{2}2
6{4}+{2}1+{3}2
----
{blank}
| If the quantifier ring is not commutative, it is still possible to propagate coefficients left or right through an `obj` `\*`-expression. Regardless of the quantifiers being https://en.wikipedia.org/wiki/Prime_element[prime elements], quantifier propagation need not preserve the factors of a `*`. In this way, if the https://en.wikipedia.org/wiki/Geometric_progression[geometric sequence] remains the same, any quantifier distribution is allowed.
<.^a|
[exec]
----
6{2}+{3}1+{4}2
6+{6}1+{4}2
6+1+{24}2
6+{12}1+{2}2
6{6}+{2}1+{2}2
----
{blank}
| Quantifiers propagate along the the multiplicative `obj` monoid via their `\*`-operator. They propagate along the additive `obj` group via their `+`-operator. In this way, if two branches have https://en.wikipedia.org/wiki/Orthogonality[orthogonal] quantifiers of the same magnitude, then when they leave the `+`-group to be additively merged onto the `*`-monoid, they cancel each other out. Various set theoretic and https://en.wikipedia.org/wiki/Quantum_computing[quantum] operations make use of constructive and deconstructive quantifier https://en.wikipedia.org/wiki/Orthogonality[interference] when computing.
<.^a|
[exec]
----
6[+{-1}1+{2}1,+{2}2]
6[+{-1}1+1,+2]{2}
6{2}[+{-1}1+1,+2]
----
{blank}
|===

===== Type Inference

==== Stream Module Axioms

.Modules
****
A https://en.wikipedia.org/wiki/Module_(mathematics)[module] for a group \$(A,+\_A,\mathbf{0}_A)\$ is a ring \$(X, +_X ,\ast_X, \mathbf{0}_X, \mathbf{1}_X )\$ such that elements of \$X\$ act on elements of \$A\$ via a function \$\cdot: X \times A \to A\$ called *scalar multiplication*.
If \$A = X\$, the action is defined by the ring's multiplicative operator.
However, when \$A \ne X\$ and moreover, when \$A\$ and/or \$X\$ is free, a ring theoretic interpretation of https://en.wikipedia.org/wiki/Linear_algebra[linear algebraic] emerges with \$A\$-based vectors (free magma) and matrices (two free magmas) being operated by \$X\$ scalars, vectors, and matrices.
The axioms for both left and right modules are provided below, where if \$A\$ is an https://en.wikipedia.org/wiki/Abelian_group[abelian group], then \$X\$ is a https://en.wikipedia.org/wiki/Bimodule[bimodule] and both sets of axioms hold.

[.center]
[cols="^1,^1",width=70,align=center]
|===
| Left \$X\$-Module Axioms                             | Right \$X\$-Module Axioms

| \$x \cdot (a +_A b) = (x \cdot a) +_A (x \cdot b) \$ | \$(a +_A b) \cdot x = (a \cdot x) +_A (b \cdot x) \$
| \$(x +_X y) \cdot a = (x \cdot a) +_A (y \cdot a) \$ | \$a \cdot (x +_X y) = (a \cdot x) +_A (a \cdot y) \$
| \$(x \ast_X y) \cdot a = x \cdot (y \cdot a)\$       | \$a \cdot (x \ast_X y) = (a \cdot x) \cdot y\$
| \$\mathbf{1}_X \cdot a = a\$                         | \$a \cdot \mathbf{1}_X = a\$
|===
****

.Poly Constructs in mmlang
================================================================

[.small]
[cols="1,1,1,5",width=40,float=right]
|===
| name        | mmlang      | latex         | description

| _split_     | `-<`        | \$\Delta\$    | scalar `*`
| _merge_     | `>-`        | \$\nabla\$    | fold `+` (linear combine)
| _branch_    | `[ ]`       | \$◊\$         | scalar `*` then fold `+`
| _combine_   | `=`         | \$\circ\$     | pairwise juxtaposition

|===

. `( )` is a polynomial constructor.
. `lst` is a polynomial with terms indexed by `int`.
. `rec` is a polynomial with terms indexed by `obj`.
. `,` is a polynomial term deliminator denoting parallel compose.
. `|` is a polynomial term deliminator denoting parallel choose.
. `;` is a polynomial term combinator denoting serial compose.
================================================================

Modules introduce a new _scalar multiplication_ binary operator \$cdot: X \times A \to A\$ typically denoted as \$X\$/\$A\$-element juxtaposition.
In mm-ADT, the module expression \[
x \cdot (a + b) \mapsto (xa + xb) \]
is realized as \[
x \Delta (a + b) \mapsto (x=>a,x=>b).
\]
The \$\Delta\$ (_split_) copys an `obj` that is _outside_ of a `poly` to the left of one or more `objs` _inside_ the `poly`.
When juxtaposed to the left and an internal `obj`, the `obj` magma's binary operator \$=>:\tt{obj} \times \tt{obj} \to \tt{obj}\$ determines the type/type, value/type, value/value, type/value resolution.
The following table provides a translation of the standard module axioms to mm-ADT.

[cols="^1,^1,^1",width=100,align=center]
|===
| Module Algebra                                       | mm-ADT Branch                              | mm-ADT Split/Merge

3.+^h| Left \$X\$-Module Axioms
| \[x \cdot (a +_A b) = (x \cdot a) +_A (x \cdot b) \] | \[[x;[a,b]] = [[x;a],[x;b]]\]               | \[x \Delta (a,b) = (x=>a,x=>b)\]
| \[(x +_X y) \cdot a = (x \cdot a) +_A (y \cdot a) \] | \[[ [x,y];a] = [[x;a],[y;a]]\]              | \[(x,y) \nabla a = (x=>a,y=>a)\nabla \]
| \[(x \ast_X y) \cdot a = x \cdot (y \cdot a)\]       | \[[[x;y];a] = [x;y;a]\]                     | \[(x;y) \nabla a = x=>y=>a\]
| \[\mathbf{1}_X \cdot a = a\]                         | \[[\underline{\mathbf{1}};a]  = a \]        | \[\underline{\mathbf{1}}=>a = a\]
3.+^h| Right \$X\$-Module Axioms
| \[(a +_A b) \cdot x = (a \cdot x) +_A (b \cdot x) \] | \[[ [a,b];x] = [[a;x],[b;x]]\]              | \[(a,b) \nabla x = (a=>x,b=>x)\nabla \]
| \[a \cdot (x +_X y) = (a \cdot x) +_A (a \cdot y) \] | \[[a;[x,y]] = [[a;x],[a;y]]\]               | \[a \Delta (x,y) = (a=>x,a=>y) \]
| \[a \cdot (x \ast_X y) = (a \cdot x) \cdot y\]       | \[[a;[x;y]] = [a;x;y]\]                     | \[a \Delta (x;y) = (a=>x;a=>x=>y) \]
| \[a \cdot \mathbf{1}_X = a\]                         | \[[a;\underline{\mathbf{1}}] = a\]          | \[a=>\underline{\mathbf{1}} = a\]
|===

===== Polynomials

NOTE: The reason for the `[split]` sugar symbol `-<`, is that it represents one wire (`-`) splitting into many (`<`).
Likewise, the reason for `>-` being the `[merge]` sugar symbol is it represents many wires merging (`>`) into one (`-`).
Finally, `[combine]` has a sugar of `=` which represents parallel wires being operated on independently.

A https://en.wikipedia.org/wiki/Polynomial[polynomial] is a _linear combination_ of _terms_ composed of _coefficients_ and _indeterminates_ typically expressed as \[
f(x) = q_1 x^1 + q_2 x^2 + q_3 x^3 + \ldots + q_n x^n, \]
where \$q_i\$ is a coefficient, \$x^i\$ is an indeterminate raised to the \$i^\text{th}\$ power, \$q_i x^i\$ is a term, and the terms are linearly combined via \$+\$.
If \$x \in \mathbb{Z}\$, then the https://en.wikipedia.org/wiki/Function_(mathematics)#Arrow_notation[signature] of \$f\$ is \$f: \mathbb{Z} \to \mathbb{Z}\$.
When \$f(x)\$ is evaluated with some \$x \in \mathbb{Z}\$, \$x\$ becomes determined and the polynomial is reduced to a single \mathbb{Z}.
For instance, \[
f(x) = 2x + 3x^2 + 6x^3 \]
is irreducible due to \$x\$ being an indeterminant variable.
If \$x =4\$, then the polynomial is solved via the reduction \[
\begin{split}
f(4) &= (2 \ast 4) + (3 \ast 4^2) + (6 \ast 4^3) \\ &= (2 \ast 4) + (3 \ast 16) + (6 \ast 64) \\ &= 8 + 48 + 384 \\ &= 440. \end{split}
\]

In mm-ADT, `poly` \$\subset\$ `obj` is the (infinite) set of polynomials.
The polynomial expression above is a `,-poly` \$\subset\$ `poly` (pronounced "comma poly") and, in `mmlang`, are expressions of the form

[.text-center]
`x \=> [x1{q1},x2{q2},x3{q3},...,xn{qn}]`

where `qi` is a _quantifier_ (coefficient), `xi` is a _type_ (indeterminate), `xi{qi}` is a quantified type (term), and the type are linearly combined via `[,]` (addition).
Instead of the terms being raised to a power (as is typical of numeric polynomials), `,-poly` terms are "raised" to a type with instructions.
This is https://en.wikipedia.org/wiki/Exponential_object[type exponentiation] which is the type-equivalent of https://en.wikipedia.org/wiki/Exponentiation[numeric exponentiation].

The aforementioned polynomial \$f: \mathbb{N} \to \mathbb{N}\$ is denoted in mm-ADT by the following `int\<=int` type.

[exec]
----
int => [int[id]{2},int[mult,int]{3},int[mult,[mult,int]]{6}][sum]
----

In \$f\$, addition and multiplication is with respects to the integer ring \$(\mathbb{Z},+,\ast,0,1)\$.
In `,-poly`, they are with respects to the stream ring, where multiplication is \$\Delta\$ and addition is \$\nabla\$.
The mm-ADT `,-poly` is a generalized algebraic structure known as a https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] that, when used to solve `int` based polynomials, the instructions `[mult]` and `[sum]` are required, where `int\<=int` type is reducible when the domain `int` is determined.

[exec]
----
4 => [int[id]{2},int[mult,int]{3},int[mult,[mult,int]]{6}]

4 => [int[id]{2},int[mult,int]{3},int[mult,[mult,int]]{6}][sum]

4 => [int[id]{2},int*{3}int,int*{6}*int][sum]

[4;[int[id]{2},int*{3}int,int*{6}*int][sum]]
----

image::poly-columns.svg[float=left,width=275]

The suggestive illustration on the left depicts a single element of some (free) ring.
There are four multiplicative https://en.wikipedia.org/wiki/Monoid[monoid] compositions diagrammed as vertical chains rooted at an \$a\$.
There is single additive https://en.wikipedia.org/wiki/Abelian_group[abelian group] element diagrammed horizontally, reflecting a (commutative) linear combination of the monoid elements.
As 1-dimensional horizontal and vertical structures, each depicts an element of a free magma (group or monoid), where 0-dimensional elements would be drawn from a non-free algebra.
Thus, the illustration contains

. four *free monoid* elements -- `(a;b;c)`, `(a;d)`, `(a;b;e)`, `(a;d;e;b)`, and
. one *free group* element -- `\((a;b;c),(a;d),(a;b;e),(a;d;e;b))`,

where, in relation to `poly`, the illustration's `*` is denoted `;` and `+` is denoted `,`.

Each mm-ADT `poly` constrains the general construction of the illustration such that one magma remain free (*unevalated*) and the other non-free (*evaluated*).
In particular, as a classic https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring], a `,-poly` maintains a *free additive group* composed of isolated *non-free multiplicative monoids*.
Thus, with respects to the illustration, the vertical \$\ast\$-compositions are "collapsed" yielding four terms (`objs`) that are unable to merge horizontally due to the free nature of the additive group.
Thus, the `,-poly` is suggestively illustrated as

image::comma-poly-example.png[width=350,align=center]

and specified in `mmlang` as

[.text-center]
`(abc{q0},ad{q1},abe{q2},adeb{q3})`.

NOTE: For visual simplicity, quantifiers are not illustrated.
Furthermore, the reason that every term of the multiplicative monoid only has a single quantifier is due to the _universal commutativity of coefficients theorem_ of https://zenodo.org/record/2565243[stream ring theory].

[cols="1,3,8,8"]
|===
| symbol    | structure                                                        | branch use                | illustration

| `,-poly`  | https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring]   | unordered biproducts +
nondeterministic branching        | image:comma-poly-example.png[]
| `;-poly`  | https://en.wikipedia.org/wiki/Trace_monoid[trace monoid]         | ordered biproducts +
serial branching                  | image:semi-poly-example.png[]
| `\|-poly` | https://en.wikipedia.org/wiki/Monoid_ring[monoid ring]           | unary biproducts +
deterministic branching           | image:pipe-poly-example.png[]
|===

[.center]
[cols="^3,^8",width=85]
|===

| `,-poly`
\[
[f,g] = \nabla \circ \Delta (f,g)  = \Diamond(f,g)
\]

copy/clone-branching +
independent terms +
\[A \times A = 2A\]
| image:comma-delta-nabla.svg[width=475,link=images/language/comma-delta-nabla.png]

| `;-poly`
\[
[f;g] = \nabla \circ \Delta (f;g) = \Diamond(f;g)
\]

serial/compose-chain +
dependent terms +
\[A^{_A A} = A \]
| image:semi-delta-nabla.svg[width=500,link=images/language/semi-delta-nabla.png]

| `\|-poly`
\[
[f \| g] = \nabla \circ \Delta (f \| g)  = \Diamond(f \| g) \\
\]

\[
\nabla \circ \iota_x \circ f \circ \pi_x \circ \Delta = B \\
\nabla \circ \iota_y \circ g \circ \pi_y \circ \Delta = \mathbf{0} \\
x \neq y
\]

either/choice-branching +
dependent terms +
\[A + A = A\]
| image:pipe-delta-nabla.svg[width=475,link=images/language/pipe-delta-nabla.png]
|===

In mm-ADT, `polys` are both `obj` products and coproducts--called https://en.wikipedia.org/wiki/Biproduct[biproducts].
They have projections (`[get]`) and injections (`[put]`) such that the following diagram commutes.

image::product-coproduct-iso.svg[width=475,align=center]

====== ,-poly

[cols="7,9"]
|===
^| `,-lst` ^| `,-rec`

| image:comma-lst-graph.svg[] | image:comma-rec-graph.svg[]
a|
[exec]
----
'x'-<(+'a',+'b',+'c')
'x'-<(+'a',+'b',+'c')>-
----
{blank}
a|
[exec]
----
'x'-<(+'s'->+'a',+'r'->+'b',+'t'->+'c')
'x'-<(+'s'->+'a',+'r'->+'b',+'t'->+'c')>-
----
{blank}
|===

[float=right,width=35]
|===
^| \$\nabla\$ on value ,-poly

a|
[exec]
----
(1,2,3)>-
(1,,3)>-
(,,3)>-
----
{blank}
a|
[exec]
----
('a'->1,'b'->2,'c'->3)>-
('a'->1,,'c'->3)>-
(,,'c'->3)>-
----
{blank}
|===

A `,-poly` (pronounced "comma poly") is a classic https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] composed of a free additive https://en.wikipedia.org/wiki/Abelian_group[abelian group] and a non-free multiplicative https://en.wikipedia.org/wiki/Monoid[monoid].
If \$a,b \in \tt{object}\$ and \$q_0, q_1 \in \tt{q}\$ are elements comprising `obj` products, then the additive operator of the `obj` stream ring is defined as \[
[a_{q_0},b_{q_1}] = \begin{cases}
[a_{q_0+q_1}]     & \text{if } a==b, \\
[a_{q_0},b_{q_1}] & \text{otherwise}, \end{cases}
\]

where \$[a_{q_0},b_{q_1}] \equiv ◊(a_{q_0},b_{q_1}) \equiv \nabla(\Delta(a_{q_0},b_{q_1})) \$ and \$+\$ denotes the respective quantifier ring's additive operator.
Given the https://en.wikipedia.org/wiki/Commutative_property[commutative] nature of the `,-poly` abelian group, the terms can be rearranged.
In https://zenodo.org/record/2565243[stream ring theory], this equality is known as the *bulking axiom* and it is of fundamental importance to efficient stream-based computing with benefits realized in both the https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff[time and space] dimensions.

[cols="7,9"]
|===
^| \$[a_{q_0},b_{q_1}]\$            ^| \$x_{q_2}[a_{q_0},b_{q_1}] \$

| image:obj-addition.png[]  | image:obj-scalar-multiplication.png[]
|===

When applying \$x \in \tt{obj}\$, the `,-poly` group is a https://en.wikipedia.org/wiki/Group_action[right action] on \$x\$ satisfying the equation below.
As an algebraic https://en.wikipedia.org/wiki/Module_(mathematics)[module], \$x\$ is an element of the right `,-poly` https://en.wikipedia.org/wiki/Module_(mathematics)[module] `obj` realizing a generalized form of https://en.wikipedia.org/wiki/Scalar_multiplication[scalar multiplication].

\[
x_{q_2}[a_{q_0},b_{q_1}] = \begin{cases}
[{xa}_{q_2*(q_0+q_1)}]            & \text{if } a==b, \\
[{xa}_{q_2*q_0},{xb}_{q_2*q_1}] & \text{otherwise}, \end{cases}
\]

The two cases above are expressed in `mmlang` below with the last two examples being the `[ ]` sugar of `-<()>-` (\$◊\$).

[exec]
----
'x'{2}-<(+{3}'a',+{4}'a')>-
'x'{2}-<(+{3}'a',+{4}'b')>-
'x'{2}[+{3}'a',+{4}'a']
'x'{2}[+{3}'a',+{4}'b']
----

====== ;-poly

[cols="7,9"]
|===
^| `;-lst` ^| `;-rec`

| image:semi-lst-graph.svg[] | image:semi-rec-graph.svg[]
a|
[exec]
----
'x'-<(+'a';+'b';+'c')
'x'-<(+'a';+'b';+'c')>-
----
{blank}
a|
[exec]
----
'x'-<(+'s'->+'a';+'r'->+'b';+'t'->+'c')
'x'-<(+'s'->+'a';+'r'->+'b';+'t'->+'c')>-
----
{blank}
|===

[float=right,width=35]
|===
^| \$\nabla\$ on value ;-poly

a|
[exec]
----
(1;2;3)>-
(1;;3)>-
(;;3)>-
----
{blank}

a|
[exec]
----
('a'->1;'b'->2;'c'->3)>-
('a'->1;;'c'->3)>-
(;;'c'->3)>-
----
{blank}
|===

The two https://en.wikipedia.org/wiki/Magma_(algebra)[magmas] of `;-poly` (pronounced "semi poly") are the free and non-free forms of the `obj` stream ring's multiplicative monoid.
The terms of `;-poly` _geometrically_ combined using the multiplicative operator \$=>\$ (denoted `;` in `poly`).
A `;-poly` is a partially commutative monoid known as a https://en.wikipedia.org/wiki/Trace_monoid[trace monoid].
If \$a,b,x \in \tt{objects}\$ and \$q_0,q_1,q_2 \in \tt{q}\$, \$◊(a;b) \equiv [a;b]\$, then the `;-poly` \$(a_{q_0} ; b_{q_1})\$ acts on \$x_{q_2}\$ as



\[
[ a_{q\_0} ; b_{q\_1} ](x_{q\_2}) = b(a(x))_{ q_2 * q_0 * q_1 }.
\]

Of particular interest, when not merging (\$\nabla\$),

\[
\Delta(x_{q\_2}, (a_{q\_0} ; b_{q\_1})) = ( a(x)_{ q_2 * q_0 } ; b(a(x))_{ q_2 * q_0 * q_1 } ).
\]

image:bubble-chamber.png[width=200,float=left] The equation above realizes a structure and process joyfully named the https://en.wikipedia.org/wiki/Bubble_chamber["bubble chamber"].
In experimental higher-energy physics, a bubble chamber is small room filled with high pressure vapor.
Particles are shot into the room and the trace they leave (called their _varpor trail_) provides physicists information that they then used to understand the nature of the particle under study -- e.g., its mass, velocity, spin, and, when capturing decay, the sub-atomic particles that compose it.
In mm-ADT, \$x\$ above (and 5 below) play the role of the _particle_ and `;-poly` the _bubble chamber_ with each term in the `;-poly` acting as a _vapor droplet_.

[exec]
----
5-<(+1;+2;+3;+4;+5)     //<1>
5-<(+1+2;+3;+4+5)       //<2>
5-<(+1+2+3+4+5)         //<3>
5-<(+1;+2;+3;+4;+5)>-   //<4>
5[+1;+2;+3;+4;+5]       //<5>
5+15                    //<6>
----
<1> `5` is propagated through the `;-poly` terms leaving a trace of it's state at each term slot.
<2> Since the elements of the \$R\$-module \$M\$ are in \$M\$, any monoid element is a legal term.
<3> A `;-poly` with single term derived via the composition of 5 other \$M\$ elements.
<4> The merge operator (\$\nabla\$) emits the final term of the `;-poly`.
<5> The sugar form of the previous expression.
<6> The last three examples are equivalent.

====== |-poly

[cols="7,9"]
|===
^| `\|-lst` ^| `\|-rec`

| image:pipe-lst-graph.svg[] | image:pipe-rec-graph.svg[]
a|
[exec]
----
'x'-<('a'{0}\|+'b'\|+'c')
'x'-<('a'{0}\|+'b'\|+'c')>-
----
{blank}
a|
[exec]
----
'x'-<('s'{0}->+'a'\|+'r'->+'b'\|+'t'->+'c')
'x'-<('s'{0}->+'a'\|+'r'->+'b'\|+'t'->+'c')>-
----
{blank}
|===

[float=right,width=35]
|===
^| \$\nabla\$ on value \|-poly

a|
[exec]
----
(1\|2\|3)>-
(1\|\|3)>-
(\|\|3)>-
----
{blank}

a|
[exec]
----
('a'->1\|'b'->2\|'c'->3)>-
('a'->1\|\|'c'->3)>-
(\|\|'c'->3)>-
----
{blank}
|===

A `|-poly` (pronounced "pipe poly") uses `|` as the `obj` term separator.
Like the `,-poly`, a `|-poly` maintains a https://en.wikipedia.org/wiki/Free_group[free additive group] and a non-free multiplicative https://en.wikipedia.org/wiki/Monoid[monoid].
However, unlike `,-poly`, the additive group is not https://en.wikipedia.org/wiki/Commutative_property[commutative].
If \$a,b,x \in \tt{objects}\$ and \$q_0,q_1,q_2 \in \tt{q}\$, then `|-poly` \$[a_{q_0} | b_{q_1}]\$ acts on \$x_{q_2}\$ as

\[
x_{q_2} [a_{q_0} | b_{q_1}] = \begin{cases}
{xa}_{q_2 * q_0} & \text{if } x_{q_2} a_{q_0} \neq \underline{\bf{0}}, \\
{bx}_{q_2 * q_1} & \text{if } x_{q_2} b_{q_1} \neq \underline{\bf{0}}, \\ \underline{\bf{0}} & \text{otherwise}.
\end{cases}
\]

Thus, while `,-lst` implements link:https://en.wikipedia.org/wiki/Union_(set_theory)[union], `|-lst` implements https://en.wikipedia.org/wiki/Null_coalescing_operator[null coalescing], where in mm-ADT, _null_ is `obj{0}` (the https://en.wikipedia.org/wiki/Zero_element[zero element] of the `obj` stream ring -- \$\underline{\mathbf{0}}\$).
Like coalesce, the order in which the terms/branches are evaluated determines the result of the computation.
This is the reason that the additive group of `|-lst` (and `|-poly` in general) is not commutative.

[exec]
----
'x'{2}[+{3}'a' | +{4}'b']  //<1>
'x'{2}[+{0}'a' | +{4}'b']  //<2>
'x'{2}[+{0}'a' | +{0}'b']  //<3>
----
<1> The first term applied to `x` is not `obj{0}` so `'a'` is added to `'x'`.
The polynomial reduces to `[plus,'a']{3}`.
<2> The first term applied to `x` is `obj{0}` and the second is not so `'b'` is added to `'x'`.
The polynomial reduces to `[plus,'b']{4}`.
<3> Both terms, when applied to `x` yield `obj{0}`.
The polynomial reduces to `obj{0}`.

`|-rec` enables link:https://en.wikipedia.org/wiki/Predicate_%28mathematical_logic%29[predicate]-based coalescing which is a form of link:https://en.wikipedia.org/wiki/Conditional_(computer_programming)[conditional branching] realized in most programming languages as link:https://en.wikipedia.org/wiki/Control_flow#If-then-(else)_statements[if/else] and link:https://en.wikipedia.org/wiki/Switch_statement[switch/case] branching.
While predicate-based branching is a function of \$\mathbb{B}\$ (`bool`), in mm-ADT it is determined by \$\tt{q}\$ (`{q}`), where __false__ is `obj{0}` (\$\underline{\mathbf{0}}\$) and __true__ is any non-zero quantifier.
The non-commutative additive group of `|-poly`, as inherited by `|-rec`, realizes link:https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Case_and_switch_statements[case-based] link:https://en.wikipedia.org/wiki/Conditional_(computer_programming)#Pattern_matching[pattern matching] branch ordering semantics.
Thus, if \$a,b,c,d,x \in \tt{objects}\$ and \$q_i \in \tt{q}\$, then

\[
x_{q_4} [a_{q_0} \to b_{q_1}  | c_{q_2} \to d_{q_3}] = \begin{cases}
{xb}_{q_4 * q_1} & \text{if } x_{q_4} a_{q_0} \neq \underline{\bf{0}}, \\
{xd}_{q_4 * q_3} & \text{if } x_{q_4} c_{q_2} \neq \underline{\bf{0}}, \\ \underline{\bf{0}} & \text{otherwise}.
\end{cases}
\]

[exec]
----
'x'{2}[+{3}'a' -> +{4}'b' | +{5}'c' -> +{6}'d']
'x'{2}[+{0}'a' -> +{4}'b' | +{5}'c' -> +{6}'d']
'x'{2}[+{0}'a' -> +{4}'b' | +{0}'c' -> +{6}'d']
----

The previous `mmlang` examples are contrived.
In practice, they keys of `|-rec` will typically leverage `[is,bool]` with the anonymous type `_` serving as the link:https://en.wikipedia.org/wiki/Switch_statement#Fallthrough[default case] of the switch.

image::pipe-rec-string-example.png[width=650,align=center]

[exec]
----
[1,10,100]-<([is,[gt,50]] -> [plus,10] | [is,[lt,5]] -> [plus,20] | _ -> [plus,30])>-   //<1>
[1,10,100][is>50 -> +10 | is<5 -> +20 | _ -> +30]                                       //<2>
----
<1> Three branches with the final branch serving as _default_.
<2> The same expression, but leveraging `mmlang` syntax sugar.

:prewrap!:

[.small]
[cols="1"]
|===
a|
[exec]
----
int{3}[is>50 -> +10 \| is<5 -> +20 \| _ -> +30][explain]
----
{blank}
|===

===== Poly Factoring

[.text-center]
[exec,eval=false]
----
int[int+2[is>0]*5<44, int+2[is>0]*-6<44, int+2[is>0]*10+7<44]
----

image::module-example-2.png[align=center]

The above expression denotes a https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] whose linearly combined terms are elements of the multiplicative monoid.
With abuse of notation, the expression below binds the monoidal terms with `+` to emphasize the prototypical polynomial form \$q_0 x^0 + q_1x^1 + q_2x^2\$.

\[
\texttt{int+2[is>0]\*5<44} \;\;+\;\; \texttt{int+2[is>0]*-6<44} \;\;+\;\; \texttt{int+2[is>0]*10+7<44} \]

Rings support both left and right https://en.wikipedia.org/wiki/Distributive_property[distributivity] such that the following derivation yields the respective equivalence.

\[
\begin{split}
abcg + abdg + abefg &= a \ast (bcg + bdg + befg) \\ &= a \ast b \ast (cg + dg + efg) \\ &= a \ast b \ast (c + d + ef) \ast g \\ \end{split}
\]

Thus `int+2[is>0]` is https://en.wikipedia.org/wiki/Factorization[factored] out on the left and `<44` is factored out on the right.

[.text-center]
[exec,eval=false]
----
int+2[is>0][*5,*-6,*10+7]<44
----

Again with an abuse of notation to emphasize the lexical structure.

\[
\texttt{int+2[is>0]} \;\ast\; (\texttt{\*5} \;\;+\;\; \texttt{*-6} \;\;+\;\; \texttt{*10+7}) \;\ast\; \texttt{<44} \]



image::module-example-1.png[align=center]

To be certain, both the factored and unfactored forms of the expression return the same result for the same input.

[exec]
----
5 => [int+2[is>0]*5<44, int+2[is>0]*-6<44, int+2[is>0]*10+7<44]
5 => int+2[is>0][*5,*-6,*10+7]<44
----

A progressive _split/merge_ example is provided to better illustrate the intermediate results of the computation.

[exec]
----
5 => -<(int+2[is>0]*5<44, int+2[is>0]*-6<44, int+2[is>0]*10+7<44)
5 => -<(int+2[is>0]*5<44, int+2[is>0]*-6<44, int+2[is>0]*10+7<44)>-

5 => int
5 => int+2
5 => int+2[is>0]
5 => int+2[is>0]-<(*5,*-6,*10+7)
5 => int+2[is>0]-<(*5,*-6,*10+7)>-
5 => int+2[is>0]-<(*5,*-6,*10+7)>-<44
----

===== Poly Expansion

Polynomials are the subject of interest primarily because they contain both multiplication and addition and, through derivations, multiplication can be translated to addition and addition to multiplication.
For instance, the left hand side of the the https://en.wikipedia.org/wiki/Binomial_(polynomial)[binomial] below is the serial composition of two parallel branches while the right hand side is the parallelization of 4 serial compositions.

\[
(a+2b)(a+4b) = a^2 + 2ba + 4ab + 8b^2 \]

[cols="3,7"]
|===
^| equation | mmlang

| \[ (a+b+b)(a+b+b+b) \] +
image:binomial-1.svg[]
a|
[exec]
----
['a','b','b']
['a','b','b'][count]
['a','b','b'][+'a',+'b',+'b',+'b',+'b']
['a','b','b'][+'a',+'b',+'b',+'b',+'b'][count]
----
{blank}
| \[ (a+2b)(a+4b) \] +
image:binomial-2.svg[]
a|
[exec]
----
['a','b'{2}]
['a','b'{2}][count]
['a','b'{2}][+'a',+{4}'b']
['a','b'{2}][+'a',+{4}'b'][count]
----
{blank}
| \[ a^2 + 2ba + 4ab + 8b^2 \] +
image:binomial-3.svg[]
a|
[exec]
----
['aa','ba'{2},'ab'{4},'bb'{8}]
['aa','ba'{2},'ab'{4},'bb'{8}][count]
----
{blank}
| \[ a^2 + 6ab + 8b^2       \] +
image:binomial-4.svg[]
a|
[exec]
----
['aa','ab'{6},'bb'{8}]
['aa','ab'{6},'bb'{8}][count]
----
{blank}
|
|===

===== Poly Embedding

image:type-ringoid-illustration.png[float=left,width=350]

A non-free element is a _zero_-dimensional point.
A free element is a _one_-dimensional line.
The carrier set of the *type ringoid* is formed from the union of the elements of `obj` stream ring's https://en.wikipedia.org/wiki/Free_abelian_group[free additive abelian group] and https://en.wikipedia.org/wiki/Free_monoid[free multiplicative monoid].
This is the _freest_ possible stream ring representation -- a https://en.wikipedia.org/wiki/Free_algebra[free ring].
With two free magmas, the type ringoid's elements are _two_-dimensional planes.
One dimension represents multiplication and the other addition.
The type ringoid is encoded in `mmlang` as a `,-lst` (additive) with zero or more `;-lst` (multiplicative) terms.
The unfactored type from the previous section is presented, followed by its two-dimensional encoding as an element of the type ringoid.

[.text-center]
[exec,eval=false]
----
[int+2[is>0]*5<44, int+2[is>0]*-6<44, int+2[is>0]*10+7<44]
----

[.text-center]
[exec,eval=false]
----
[[int;+2;[is>0];*5;_;<44],[int;+2;[is>0];*-6;_;<44],[int;+2;[is>0];*10;+7;<44]]
----

In a manner analogous to polynomials in https://en.wikipedia.org/wiki/Linear_algebra[linear algebra], the free monoids of the polynomial can be organized into a https://en.wikipedia.org/wiki/Matrix_(mathematics)[matrix], where the following equations maintain `,` and `;` tokens to help orient the reader and the multiplicative identity `_` pads rows to ensure a proper \$n \times m\$-matrix.

\begin{bmatrix}
\tt{int}; & +2; & \tt{[is>0]}; & *5; & \_ ; & <44, \\ \tt{int}; & +2; & \tt{[is>0]}; & *{-6}; & \_ ; & <44, \\ \tt{int}; & +2; & \tt{[is>0]}; & *10; & +7 ; & <44 \\ \end{bmatrix}

A left `obj`-module (a row vector) can be factored out of the matrix leaving an expression of the form \$\mathbf{v}^{\top} \mathbf{M}\$.

[.text-center]
[exec,eval=false]
----
[[int;+2;[is>0]];[[*5;<44],[*-6;<44],[*10;+7;<44]]]
----

\[
\begin{bmatrix}
\tt{int}; & +2; & \tt{[is>0]} \end{bmatrix} ; \begin{bmatrix}
*5; & \_ ; & <44, \\ *{-6}; & \_ ; & <44, \\ *10; & +7 ; & <44 \\ \end{bmatrix}
\]

Similarly, a right `obj`-module https://en.wikipedia.org/wiki/Scalar_(mathematics)[scalar] can be factored out leaving an expression of the form \$\mathbf{v}^{\top} \mathbf{M} u \$.

[.text-center]
[exec,eval=false]
----
[[int;+2;[is>0]];[*5,*-6,[*10;+7]];<44]
----

\[
\begin{bmatrix}
\tt{int}; & +2; & \tt{[is>0]} \end{bmatrix} ; \begin{bmatrix}
*5; & \_ , \\ *{-6}; & \_ , \\ *10; & +7 \\ \end{bmatrix} ; <44 \]

This fully factored form can be evaluated with `obj`-scalar left multiplication.

\[
\begin{split}
& 5; \begin{bmatrix}\tt{int}; & +2; & \tt{[is>0]} \end{bmatrix} ; & \begin{bmatrix} *5; & \_ , \\ *{-6}; & \_ , \\ *10; & +7 \\ \end{bmatrix} ; <44 \\ &= \begin{bmatrix}5; & +2; & \tt{[is>0]} \end{bmatrix} ; & \begin{bmatrix} *5; & \_ , \\ *{-6}; & \_ , \\ *10; & +7 \\ \end{bmatrix} ; <44 \\ &=7 ; \begin{bmatrix}
*5; & \_ , \\ *{-6}; & \_ , \\ *10; & +7 \\ \end{bmatrix} ; <44 = & \begin{bmatrix}
35; & \_ , \\ -42; & \_ , \\ 70; & +7 \\ \end{bmatrix} ; <44 = \begin{bmatrix}
35, \\ -42, \\ 77 \\ \end{bmatrix} ; <44 =\begin{bmatrix}
\tt{true}, \\ \tt{true}, \\ \tt{false}   \\ \end{bmatrix}
= \begin{bmatrix}
\tt{true}\{ 2 \}, \\ \tt{false}           \\ \end{bmatrix}
\end{split}
\]

[exec]
----
[5;[[int;+2;[is>0]];[*5,*-6,[*10;+7]];<44]]

5-<(int;+2;[is>0];-<(*5,*-6,-<(*10;+7)))
5-<(int;+2;[is>0];-<(*5,*-6,-<(*10;+7)>-)>-;<44)>-
----

Again, to be certain, all three derivations yield the same result for the same input.

[exec]
----
[5;[[int;+2;[is>0];*5;_;<44],[int;+2;[is>0];*-6;_;<44],[int;+2;[is>0];*10;+7;<44]]]
[5;[[int;+2;[is>0]];[[*5;<44],[*-6;<44],[*10;+7;<44]]]]
[5;[[int;+2;[is>0]];[*5,*-6,[*10;+7]];<44]]
----

The linear algebraic type ringoid compartmentalizes the type induced at the individual instruction-level.
This is the _absolutely_ freest representation of a ring(oid).
This "cellular form" is well suited to manipulation by the processor.
At compile-time, factoring a matrix representation can be leveraged for optimization and rewriting.
At evaluation runtime, the free type ringoid provides a deconstructed, 2-dimensional https://en.wikipedia.org/wiki/Pipeline[pipeline] architecture that can be partitioned across machines of a cluster and/or threads of a machine.

The https://en.wikipedia.org/wiki/Universal_property[universal property] of monoid mappings is realized as the "lifted" `poly` syntactic encoding of an mm-ADT type.

image::monoid-homomorphisms.png[align=center,width=500]