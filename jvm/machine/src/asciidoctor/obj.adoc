:imagesdir: ./images/obj


== The Obj Graph

An mm-ADT program is a *type*. The `mmlang` parser converts a textual representation of a type into a type `obj`. A type is inductively defined and is encoded as a https://en.wikipedia.org/wiki/Path_(graph_theory)[path] within a larger *type graph*. The type's path is a graphical encoding specifying a data flow https://en.wikipedia.org/wiki/Pipeline_(computing)[pipeline] that when evaluated, realizes elements of the type (i.e. computed resultant values). These values also have a graphical encoding paths in a *value graph*. Together, the type graph and the value graph form the *obj graph*.

Every aspect of an mm-ADT computation from composition, to compilation, and ultimately to evaluation is materialized in the `obj` graph. The following itemizations summarizes the various roles that the `obj` graph throughout a computation.

* *Composition*: The construction of a type via the https://en.wikipedia.org/wiki/Tacit_programming[point-free] style of `mmlang` is a the lexical correlate of walking the `obj` graph from a source vertex (domain ctype) across a series of instruction-labeled edges (`inst`) to ultimately arrive at a target vertex (range ctype). The path, a https://en.wikipedia.org/wiki/Free_object[free object], contains both the type's signature and definition.
* *Compilation*: A path in the type graph can be prefixed with another ctype (e.g. placing `int` before `_`). In doing so, the path's domain has been alterered and the path is recomputed to potentially yield a variant of the original path (e.g. a type inferenced path).
* *Rewrite*: Subpaths of a path in the type graph can be specified as being semantically equivalent to another path in the type graph via `poly` lifted rewriting `(y)\<=(x)`. Subsequent compilations and evaluations of the path may yield path variants.
* *Optimization*: Every instruction in `inst` has an associated cost dependent on the underlying storage and processor. Rewrites create a superposition of programs. Given that the `obj` graph https://en.wikipedia.org/wiki/Commutative_diagram[commutes], a https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm[weighted shortest path] calculation from a domain vertex to a range vertex is an example of a simple technique for choosing an efficient execution plan.
* *Variables*: Variable bindings are encoded in instructions. When the current instruction being evaluated requires historic state information, the `obj`^op^ graph (with edges reversed) is searched in order to locate the vertex incident to a variable `inst`.
* *Evaluation*: Program evaluation binds the type graph to the value graph. When a type path is prefixed with a value `obj`, the instructions along the path operate on the value, where the path's target vertex is the result of the computation.

This section will discuss the particulars of the aforementioned uses of the `obj` graph.

=== State

Let \$(M,\cdot,e)\$ be a https://en.wikipedia.org/wiki/Monoid[monoid], where \$e \in M\$ is the https://en.wikipedia.org/wiki/Identity_element[identity element] and there exists an element \$e' \in M\$ that also acts as an identity such that for every \$ x \in M \$, \$x \cdot e = x\$ and \$x \cdot e' = x\$, then because \$e \cdot e' = e\$ and \$e \cdot e' = e'\$, it is the case that \$e = e \cdot e' = e'\$ and \$e = e'\$.
Thus, every monoid has a *single unique identity*.
However, in a https://en.wikipedia.org/wiki/Free_monoid[free monoid], where element composition history is preserved, it is possible to record \$e\$ and \$e'\$ as distinctly _labeled_ elements even though their role in the non-free monoid's binary composition are the same -- namely, that they both act as identities.


[.small]
[cols="2,1,2" width=42, float=right]
|====
| idiom                                                                      | inst           | description

| https://en.wikipedia.org/wiki/Variable_%28computer_science%29[variables]   | `[to]`         | `obj` references
| https://en.wikipedia.org/wiki/Data_type[type definitions]                  | `[define]`     | `type` mappings
| https://en.wikipedia.org/wiki/Category_(mathematics)[models]               | `[model]`      | domain of discourse
| https://en.wikipedia.org/wiki/Reversible_computing[reversible computing]   | `[path]`       | computing history
|====

It is through *multiple distinct identities* in `inst` that mm-ADT supports the programming idioms in the associated table. The general approach is __state is stored along the path of the `obj`.__

[exec]
----
6 => int[plus,[mult,2]][path]
8 => int[plus,[mult,2]][path]
----

Every `obj` exists as a distinct vertex in the `obj` graph. If \$b \in \tt{obj}\$ has an incoming edge labeled \$i \in \tt{i\nst}\$, then when applied to the outgoing adjacent vertex \$a\$, \$b\$ is computed. Thus, the edge \$a \to_i b\$ records the instruction and incoming `obj` (\$a\$) that yielded the `obj` at the head of the edge (\$b\$). Since types are defined *inductively* and their respective values generated *deductively* via instruction evaluation along the type's *path*, the path contains all the information necessary to effect https://en.wikipedia.org/wiki/State_(computer_science)[state]-based computing. The path of an `obj` is accessed via the `[path]` instruction. The output of `[path]` is a `;-lst` -- i.e., an element of the `inst` https://en.wikipedia.org/wiki/Syntactic_monoid[syntactic monoid]. This path `lst` is also a https://en.wikipedia.org/wiki/Product_(category_theory)[product] and as such, can be https://en.wikipedia.org/wiki/Reflection_(computer_programming)[introspected] via it's projection morphisms (e.g., via `[get]`).

[exec]
----
8 => int[plus,1][mult,2][lt,63]                                                           //<1>
8 => int[plus,1][mult,2][lt,63][path]                                                     //<2>
8 => int[plus,1][mult,2][lt,63][path][get,5][get,0]                                       //<3>
----
<1> The evaluation of an `bool\<=int` type via 8.
<2> The `obj` graph path from 8 to `[lt,63]`.
<3> A projection of the instruction `[lt,63]` from the path and then the first argument of the `inst`.

mm-ADT's *multiple identity instructions* simply compute the identity function \$f(x) \mapsto x\$, but as edge labels in the `obj` graph, they store state information that can be later accessed via trace-based path analysis (i.e. via `[path]`).
In effect, the execution context is transformed from a memory-less https://en.wikipedia.org/wiki/Finite-state_machine[finite state automata] to a https://en.wikipedia.org/wiki/Processor_register[register]-based https://en.wikipedia.org/wiki/Turing_machine[Turing machine].

==== Variables

The `[to]` instruction's type definition is `a\<=a[to,_]`. The argument to `[to]` is a *named anonymous type*. For every incoming \$a \in \tt{obj}\$, there is an outgoing \$a\$ whose path has been extended with the `[to]` instruction. An example is provided below.

[.center]
[cols=^.^1,width=40,grid=none,frame=none]
|====
a|
[exec,eval=false,prompt=""]
----
_[plus,1][to,x][plus,2][mult,x]
----
{blank}
|====

Suppose `int` is applied to the above anonymous type. This triggers a cascade of events whereby `[plus,1]` maps `int` to `int[plus,1]`, then `[to,x]` maps `int[plus,1]` to `int[plus,1][to,x]`, and so forth. The resultant compiled `int`-type can then be evaluated by an `int` value such as 9. In the commuting diagram below, the top instruction sequence forms a value graph (*evaluation*), the middle sequence a type graph (*compilation*), and the bottom, an __ un__typed graph (*composition*). The union of these graphs via the https://en.wikipedia.org/wiki/Inclusion_map[inclusion morphism] (`[type]`) is the complete `obj` graph of the computation.

NOTE: In `mmlang`, the `[to]` instruction's sugar is `< >`. It is the only instruction whose sugar is printed as opposed to its `[ ]` form.

[.center]
[cols="1",width=50,frame=none,grid=none]
|====
a|
[exec]
----
_   => [plus,1]<x>[plus,2][mult,x]
int => _[plus,1]<x>[plus,2][mult,x]
9   => int[plus,1]<x>[plus,2][mult,x]
----
{blank}
|====

image::linear-variable-example.svg[align=center,width=600]

image::linear-variable-example-2.svg[align=center,width=350,float=right]

The primary idea concerning variable state is that when `[mult,x]` is reached by the `int` value 12 via instruction application, the anonymous type `x`  must be *resolved* before `[mult]` can evaluate. To do so, the instruction `[to,x]` is searched for in the path history of 12. When that instruction is found, the range (or domain as it's an identity) replaces `x` and `[mult,10]` is evaluated and the edge \[12 \rightarrow_{\texttt{[mult,10]}} 120 \] extends the value graph. The intuition for this process is illustrated on the right.

[exec]
----
9 => int[plus,1]<x>[plus,2][mult,x][path]                                                 //<1>
int[plus,1]<x>[plus,2][mult,x][explain]                                                   //<2>
----
<1> The `[path]` instruction provides the path of the current `obj` as a `;-lst`.
<2> The `[explain]` instruction details the scope of state variables.

The variable's https://en.wikipedia.org/wiki/Scope_(computer_science)[scope] starts at `[to]` and ends when there is no longer a path to `[to]`. If an `inst` argument is a type (e.g. `[mult,[plus,x]]`), then the *child type* (`[plus,x]`) path extends the *parent type* (`[mult]`) path. As such, the child type has access to the variables declared in the parent composition up to the `inst` containing the child type (`[mult]`). Finally, if `[to,x]` is evaluated and later along that path `[to,x]` is evaluated again, all subsequent types will resolve `x` at the latter `[to,x]` instruction. That is, the graph search halts at the first encounter of `[to,x]` -- the https://en.wikipedia.org/wiki/Shortest_path_problem[shortest path] to a declaration.

[exec,exception=LanguageException]
----
2 => int<x>[plus,<y>][plus,y]                                                             //<1>
2 => int<x>[plus,[plus,x]<x>[plus,x]][plus,x]                                             //<2>
2 => int<x>[plus,[plus,x]<x>[plus,x]][plus,x][path]                                       //<3>
int<x>[plus,int<y>[plus,int<z>[plus,x][plus,y][plus,z]][plus,y]][plus,x][explain]         //<4>
----
<1> The variable `y` is declared in a branch nested within the retrieving branch.
<2> The variable `x` is redefined in the nested branch and recovers its original value when the nested branch completes.
<3> The value path of the previous evaluation highlighting that the final `[plus,x]` resolved to `[plus,2]`.
<4> A multi-nested expression demonstrating the creation and destruction of variable scope.

==== Definitions

A *definition* takes one of the two familiar forms
\[
b<=a
\]
or
\[
b:a
\]
where, for the first, \$b\$ is _generated_ by \$a\$ and for the second, \$b\$ is _structured_ as \$a\$ and, when considering no extending instructions to the \$b<=a\$ form, \$b<=a \cong b:a\$ such that \$a\$ is _named_ \$b\$.

For most of the documentation, the examples have been presented solely from within the `mm` model-ADT where there are 6 types: `bool`, `int`, `real`, `str`, `lst`, and `rec` along with their respective instructions. It is possible to extend `mm` with new types that are ultimately _grounded_ (Cayley rooted) in the `mm` model-ADT types. This is the purpose of the `[define]` instruction.

Assume the two type definitions below: `vertex` and `edge`. The associated diagram is not commutative and the `.` prefixes on the `inst` morphisms denote the `mmlang` sugar notation for `[get]`, where `.outV` is sugar for `[get,'outV']`.

[.center]
[cols="7,5",width=85,grid=none,frame=none]
|====

a|
[exec,prompt="",eval=false]
----
[define,vertex:('id'->int)] %
[define,  edge:('outV'->vertex,'inV'->vertex)]
----
{blank}
| image:digraph-model-1.svg[align=center]

|====

The `vertex` and `edge` definitions can be used within a larger mm-ADT program/type.

[exec]
----
1 => edge<=int[model,mm][define,vertex:('id'->int), edge:('outV'->vertex,'inV'->vertex)] %
              -<('outV'->-<('id'->_),'inV'->-<('id'->+1))
----

The first line above reads: Given the value 1, generate an `edge` from that `int` according to the definitions of the `mm` model-ADT extended with two types `vertex` and `edge`. The two new types are defined _in situ_, where a `vertex` is a https://en.wikipedia.org/wiki/Refinement_type[refinement] on `rec` constraining `rec` to an `'id'` key with an `int` value and, similarly, `edge` constrains `rec` to keys `'outV'` (edge tail) and `'inV'` (edge head) with corresponding `vertex` values. The second line specifies how this mapping should be done. The incoming `int` is *split* (`-<`) across a two element `rec`, where their values are single element `recs` which again split the `int` to be the values for the `'id'` keys. Given `edge\<=int`, an `edge` is the desired output. The `mm` model (and extending definitions) determine the "best" way to construct an `edge` given the structure thus far. The answer being simply to label the corresponding components accordingly and thus, the output of the program is the resultant `edge` structure.

NOTE: Type definitions (using `[define]` or `[model]`) denote canonical mappings within a https://en.wikipedia.org/wiki/Domain_of_discourse[domain of discourse] (i.e., a *model*). Programs that maintain instructions after `b\<=a` serve to manipulate `a` just enough to get it to the head of a type definition path that will ultimately reach `b`. In a well constrained data environment, mm-ADT code has less intermediate instructions with a style of the form \$a \implies b \implies c \implies \ldots \implies z\$, relying on the type definitions to string together a well-reasoned path from source to sink.

The `[define]` instruction is placed at the start of the program (the desired start of the scope of the definition(s)). To ease matters, definition placement can happen automatically by way of a *type prefix*. The type prefix is a generalization of a https://en.wikipedia.org/wiki/Comparison_of_programming_languages_(syntax)#Libraries[library statement] such as `import` or `module` found in other programming languages. The generalization is that a type prefix can be any type (not just `[model]` and `[define]` instructions). The type prefix is concatenated to the program type prior to compilation, where this operation is made sound by the free `inst` monoid.

NOTE: A more sophisticated library infrastructure is provided by the `[model]` instruction with a complete treatment forthcoming.

[exec,exception=LanguageException]
----
:[model,mm][define,vertex:('id'->int),edge:('outV'->vertex,'inV'->vertex)]     //<1>
1 => edge<=int-<('outV'->-<('id'->_),'inV'->-<('id'->+1))                      //<2>
1 => edge<=int-<('outV'->-<('ID'->_),'inV'->-<('ID'->+1))                      //<3>
1 => edge<=int-<('outV'->-<('id'->_),'inV'->-<('id'->+1),'extra'->'data')      //<4>
----
<1> The type prefix extends the `mm` model-ADT with `vertex` and `edge` definitions.
<2> The `vertex` and `edge` type definitions are automatically prepended to all subsequent programs.
<3> If there is no mapping (path) from input to output via the type definitions, the program fails.
<4> Extraneous (non-ambiguous) data is mapped to the terminal \$\mathbf{0}\$ ensuring a proper type transformation.

==== Rewrites

////
Each step of that walk is an instruction forming an edge in the type graph.
For instance, the type

[.text-center]
`int[is,[eq,int]]`

describes a https://en.wikipedia.org/wiki/Reflexive_relation[reflexive graph] with vertices are in `int` and edges labeled `[is,[eq,int]]`.
There are other mm-ADT types (an infinite amount in fact) that are related to `int[is,[eq,int]]` by a https://en.wikipedia.org/wiki/Graph_homomorphism[graph homomorphism].
A few such types are itemized below.

[source]
----
int[plus,0]
int[mult,1]
int[plus,1][plus,-1]
int[plus,2][plus,-2]
int[plus,3][plus,-3]
...
----

Note a common pattern.
The type `int[plus,x:int][plus,x:int[neg]]` captures an infinite number of more specific types that are homomorphic to `int[is,[eq,int]]`. https://en.wikipedia.org/wiki/Higher-order_function[Higher order type] are defined using mm-ADT `polys`.

[.text-center]
`(int[is,[eq,int]])\<=(int[plus,x:int][plus,x:int[neg]])`

In category theory, a _type-to-type_ mapping that https://en.wikipedia.org/wiki/Morphism[preserves structure] is called a https://en.wikipedia.org/wiki/Functor[functor].
From the perspective of mm-ADT, two new "ctypes" are linked in a domain/range `\<=`-relation within a higher-order https://en.wikipedia.org/wiki/Identity_function[identity type] with respective signature.
The identity is apparent in that there are no instructions required to coerce an `obj` of the domain to an `obj` of the range.
This is analogous to `int\<=int`, save that the mapping is not predicated on https://en.wikipedia.org/wiki/Isomorphism[isomorphism], but on a broader relationship called a https://en.wikipedia.org/wiki/Surjective_function[surjective] homomorphism (a  https://en.wikipedia.org/wiki/Rewriting[reduction]).
Any type containing only a type signature `()\<=()` says that the domain type is equal to the range type such that the domain can be https://en.wikipedia.org/wiki/Abstract_rewriting_system[substituted] for the range.

[source]
----
[define,(int[is,[eq,int]])<=(int[plus,x][plus,x[neg]])][int][plus,10][plus,-10]
----
////

image::type-to-type-type.png[width=700,align=center]

////
The type `int[is,[eq,int]]` has an https://en.wikipedia.org/wiki/Isomorphism[isomorphic] image in `int`, where the reflexive self-loop paths in `int[is,[eq,int]]` are contracted to 0-length paths.
The isomorphism realizes `int` as a classic set without structure because the type `int` has no instructions and thus, no type graph edges.

[source]
----
mmlang> [define,int<=(int[is,[eq,int]])]
        [define,(int[is,[eq,int]])<=(int[plus,x:int][plus,x:int[neg]])]
        [int][plus,10][plus,-10]
==>int
----

The composition of two structure preserving type morphisms yields a new type--namely, `int\<=(int[plus,x:int][plus,x:int[neg]])`.
////

=== Models

mm-ADT organizes types into *models*. The 4 _mono_ types (`bool`,`int`,`real`,`str`) and the 2 _poly_ types (`lst`, `rec`) are defined in a model called `mm` (the _mm_ of mm-ADT). When the instruction `[model,mm]` is evaluated, the `mmlang` file below is loaded (`mm.mm`).

[source]
----
include::../../src/main/resources/model/mm.mm[]
----

A model-ADT can be defined in a `rec`, where the keys are canonical types (*ctypes*) and the values are `lsts` of derived types (*dtypes*). This encoding denotes the coproduct of a ctype and a product of derivations to that type such that any model \$\mathbf{m}\$ is defined
\[
\begin{split}
\texttt{model}_\mathbf{m} &= \prod_{i=0}^{|\mathbf{m}|} \texttt{ctype}_i + (\texttt{dtype}_i^0 \times \texttt{dtype}_i^1 \times \ldots \times \texttt{dtype}_i^n) \\
                          &= \prod_{i=0}^{|\mathbf{m}|} \texttt{ctype}_i + \texttt{dtype}_i^n.
\end{split}
\]
There are more ctypes than the 6 https://en.wikipedia.org/wiki/Primitive_data_type[base types] specified in `mm`. In general, a ctype in one model may be a dtype in another. If model \$\mathbf{m}\$ has \$\tt{ctypes}_\mathbf{m}\$ derived from types in model \$\mathbf{n}\$, then \$\tt{dtypes}_{\mathbf{n}} \subseteq \tt{ctypes}_{\mathbf{m}}\$. However, `mm` is unique in that the `mm` types are _universally grounded_ and
\[
\begin{split}
\textbf{mm} &= \prod_{i=0}^6 \texttt{ctype}_i + (\;) \\
            &= \prod_{i=0}^6 \texttt{ctype}_i + \texttt{Unit}_i \\
            &= \prod_{i=0}^6 \texttt{ctype}_i + \mathbf{1}_i
\end{split}
\]

That is, every `mm` ctype is derived from the https://en.wikipedia.org/wiki/Identity_function[identity type]. For example, the field `bool \-> ( )` in the `mm` `rec` above denotes \$\tt{bo\ol} \+ \mathbf{1}_\tt{bo\ol}\$. The `bool` ctype has one dtype definition: `bool` which is short hand for `bool\<=bool`, which, when considering the quantifier ring, is shorthand for `bool{1}\<=bool{1}`. The definition of `bool` is it's https://en.wikipedia.org/wiki/Reflexive_relation[reflexive] identity: `bool`.
\[
\texttt{bool}\Leftarrow\texttt{bool} \equiv \texttt{bool} + \mathbf{1}_\texttt{bool}.
\]

.Model-ADT Subgraphs of the `obj` Graph
================================================================
image::model-adt.svg[width=450,float=right]

The illustration on the right shows 3 different models and their respective types. Every edge is a type definition of the form:

[.center]
[cols=^1,frame=none,grid=none,width=20]
|===
a|
[source]
----
b<=a[inst{*}]
----
{blank}
|===

A type definition's instructions specify the specific, https://en.wikipedia.org/wiki/Discrete_system[discrete] computational steps (`inst`) necessary to transform `a` (domain) into `b` (range). These instructions are the steps of the https://en.wikipedia.org/wiki/Inductive_type[type induction] which form the edges of the `obj` graph (i.e., the morphisms in the `obj` https://en.wikipedia.org/wiki/Diagram_(category_theory)[category diagram] and the edges in the `obj` https://en.wikipedia.org/wiki/Cayley_graph[Cayley graph]). In the illustration, three sorts of type definitions are highlighted:

* `xtype\<=int[f]` (**intra-model**): In `xmodel`, `xtype` is grounded at `int` in `mm`.
* `ytype\<=xtype[g]` (**inter-model**): In `xmodel`, `ytype` can be reached via `xtype`.
* `atype\<=rec[h][i]` (**trans-model**): In `amodel`, `atype` is grounded at `rec` in `mm` via `ytype` in `xmodel`.
================================================================


==== Model Building

The `mm` model-ADT is too simple to be educational. The following section build a model-ADT in stages. The final model is `pg` and denotes the category of *property graphs*. Before reaching `pg`, smaller tutorial models will be presented starting at `pg_1`, then `pg_2`, and so forth.

[source]
----
include::../../src/main/resources/model/examples/pg_1.mm[]
----
image::digraph-type-path-1.svg[width=625,align=center]
<1> A `graph` is a `lst` containing 0 or more `edges`.
<2> The `mm` specification of a canonical `vertex` (an `inst`-less ctype).
<3> A path from an `int` to a `vertex`.
<4> The `mm` specification of a canonical `edge` (an `inst`-less ctype).
<5> A path from a 2-tuple `vertex` `;-lst` to a `edge`.

Note that every type is associated with a `lst` of type definition whose *range* is the type. Diagrammatically, every type is associated with all it's incoming `obj` graph paths called _type paths_.

===== Type Paths

A type is a *path* through the `obj` graph via type vertices and `inst` edges. A *type path* is a path through the `obj` graph via type subgraphs. A type path is specified via a type definition. In general, every model type definition is a mapping of the form:

[.center]
[cols=^1,width=45,grid=none,frame=non]
|====

a|
[exec,eval=false,exception=LanguageException]
----
a -> (a:poly,a<=b,a<=c,a<=d)
----
|====

Thus, there are two sorts definitions.

. *model ctypes*: a model typically specifies a set of _canonical types_, or ctypes for short. This is analogous to `bool`, `int`, etc. being ctypes in `mm`. Thus, `vertex`, `edge`, etc. are the ctypes of `pg`. The canonical type of `vertex` is `vertex:('id'\->int)`
. *model dtypes*: a model's ctypes must be defined in terms of types that are ultimately are grounded in `mm`. Moreover, intra-model type morphisms specify how to move between types within a model. Such types are _derived types_ and are defined inductively via a path through the type graph of the `obj` graph.

[exec]
----
:[model,pg_1]
5
5 => vertex                                                                //<1>
(5;6) => (vertex;vertex) => edge                                           //<2>
(5;6) => edge                                                              //<3>
5-<(vertex;vertex)=>edge                                                   //<4>
----
<1> An `int` value morphed into a `vertex`.
<2> An `int` value pair morphed into a `vertex` pair and then into an edge (a fine-grained *type path*).
<3> An `int` value pair morphed into an edge (a course-grained *type path*).
<4> An `int` value split into `vertex` clone pairs and then morphed into a https://en.wikipedia.org/wiki/Loop_(graph_theory)[self-loop] edge.

The above example demonstrates the use of `;-lst` as both a https://en.wikipedia.org/wiki/Coproduct[coproduct] and a https://en.wikipedia.org/wiki/Product_(category_theory)[product] -- i.e., a https://en.wikipedia.org/wiki/Biproduct[biproduct]. The `(vertex;vertex)` pair is created via a split `-<` which serves as the coproduct injections \$\iota_0\$ and \$\iota_1\$. From this vertex coproduct, the `edge` definition projects out each component of via `.0` (`[get,0]`) and `.1` (`[get,1]`). Thus, the coproduct is also a product. For this reason, the https://en.wikipedia.org/wiki/Unicode[Unicode] character for https://en.wikipedia.org/wiki/Pi[pi] (π), the conventional symbol for product https://en.wikipedia.org/wiki/Projection_(mathematics)[projection] serves as another `mmlang` sugar for `[get]`.

[exec]
----
(1;2)-<('ι0'->π0,'ι1'->π1)
----

===== Model Paths

The `pg_1` model extends `mm` via `pg_1\<=mm`. Note that it is possible for a model to define types that have no incoming paths from `mm`. For example:

[exec,exception=LanguageException]
----
:[model,ex:('type'->(A->(A<=B),B->(B<=C),C->(C<=A)))]
6 + 12
A => D
A => B => C
----

This is not typical. In practice, every model-ADT will extend `mm` or some other model, where there exists a path of model extensions to `mm`. This is the concept of a *model path* which is analogous to a *type path* but instead of mapping _types-to-types_, a model path maps sets of types to sets of types--or _models-to-models_.

That is, a type is associated with a list of type definitions for which the type is the range. These type definitions can be understood as single-step paths through the `obj` graph, such that the composition of these types is the diagram of the model.

.model-ADT Application Programming Interfaces
================================================================
The software development pattern espoused by mm-ADT is one in which software libraries (https://en.wikipedia.org/wiki/API[APIs]) are large https://en.wikipedia.org/wiki/Commutative_diagram[commuting diagrams] constructed via domain/range concatenation of \$b<=a\$ types. With a diagram rich in paths, mm-ADT application code will tend towards a _look-and-feel_ similar in form to
\[
a \Rightarrow b \Rightarrow c \Rightarrow d[x][y][z] \Rightarrow e \Rightarrow \ldots \Rightarrow z,
\]
where \$d[x][y][z]\$ denotes some intermediate instructions that operate on \$d\$ prior to translating \$d\$ to \$e\$.

These commuting diagrams are called *models* and are stored in model-ADT files analogous to `mm.mm` and `digraph.mm`. Models can be composed using the same ring algebraic mechanisms as type composition as they themselves are simply large product types that when used with `[branch]`, serve as https://en.wikipedia.org/wiki/Lookup_table[lookup tables] for type path resolution.
================================================================

==== Type Patterns

[cols="^1,4,9"]
|===
| type      | description | mmlang example

| https://en.wikipedia.org/wiki/Anonymous_function[anonymous] | A type with an unspecified domain.
a|
[exec]
----
5 => [plus,2]
5 => [plus,[plus,2]]
----
{blank}

| https://en.wikipedia.org/wiki/Monomial[monomial] | A https://en.wikipedia.org/wiki/Primitive_data_type[primitive type] that is a single term and coefficient.
a|
[exec,exception=LanguageException]
----
5   => int
'5' => int
5   => int{10}
----
{blank}
| https://en.wikipedia.org/wiki/Polynomial[polynomial] | A https://en.wikipedia.org/wiki/Composite_data_type[composite type] containing a linearly combination of terms and their coefficients.
a|
[exec,exception=LanguageException]
----
(+{2}3,+{3}4,+{4}5)
5-<(+{2}3,+{3}4,+{4}5)
5-<(+{2}3,+{3}4,+{4}5)>-[sum]
----
{blank}
| https://en.wikipedia.org/wiki/Refinement_type[refinement] | A subset of another type.
a|
[exec,exception=LanguageException,none=""]
----
:[define,nat<=int[is>0]]
5 => nat
0 => nat
----
{blank}
| https://en.wikipedia.org/wiki/Recursive_data_type[recursive] | A type with components of the same type.
a|
[exec,exception=LanguageException,none=""]
----
:[define,list<=[(_){?}\|(_,list)]]
(1)             => list
(1,(1))         => list
(1,(1,(1)))     => list
(1,(1,(1,(1)))) => list
1               => list
(1,1)           => list
----
{blank}
| https://en.wikipedia.org/wiki/Dependent_type[dependent] | A type with a definition variable to the incoming `obj`.
a|
[exec,none=""]
----
5 => [is>int]
5 => [plus,int]
----
{blank}
| https://en.wikipedia.org/wiki/Category_(mathematics)[model] | A set of types and path equations.
a|
[exec,exception=LanguageException,none=""]
----
:[model,social:('type'->  %
  (person -> (person:('name'->str,'age'->nat)), %
   nat    -> (nat<=int[is>0])))]
('name'->'marko','age'->0)                => person
('name'->'marko','age'->29)               => person
('name'->'marko','age'->29,'alive'->true) => person

----
{blank}
|===

===== Refinement Types

https://en.wikipedia.org/wiki/Refinement_type[Refinement types] extend a language's base types with https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)[predicates] that further _refine_ (constrain) the base type values. A classic example is the set of natural numbers (\$\mathbb{N}\$) as a refinement of the set of integers (\$\mathbb{Z}\$), where \$\mathbb{N} \subset \mathbb{Z}\$. In https://en.wikipedia.org/wiki/Set-builder_notation#Sets_defined_by_a_predicate[set builder notation], specifying the set of integers and a predicate to limit the set to only those integers greater than 0 is denoted
\[
\mathbb{N} = \{n \in \mathbb{Z} \;|\; n > 0\}.
\]
In mm-ADT, the above is denote `int[is>0]` which is the sugar form of `int{?}\<=int[is,[gt,0]]`. mm-ADT supports user defined types. In fact, mm-ADT's primary goal is a way to elegantly express types, mappings between them such that data structures can be viewed from different algebraic and domain perspectives. The `[define]` instruction defines a type within the current context (i.e. the current type nest level). In a forthcoming section on _model-ADTs_, the more general `[model]` instruction will be presented.

.mm-ADT Type Prefix
================================================================
All `mmlang` examples that start with `:` are defining a *type prefix*. This type is prepended to all subsequent expressions. In many ways, a type prefix is like an https://en.wikipedia.org/wiki/Assembly_language#Assembler[assembler] https://en.wikipedia.org/wiki/Object_file[object file]. On the other hand, model-ADTs (of `[model]`) are similar to the `import` of https://en.wikipedia.org/wiki/Class_(computer_programming)[class files] in https://en.wikipedia.org/wiki/Object-oriented_programming[object-oriented languages].
================================================================

[exec,none="",exception=LanguageException]
----
:[model,mm][define,nat<=int[is>0]]
10 => nat
-1 => nat
10 => nat[plus,5]
10 => nat[plus,5][plus,-15]
----

[discrete]
====== Poly Refinement

There are two canonical `poly` types: `lst` and `rec`. Any restriction on their respective values is a *refinement*. The example below defines a `date` to be a `;-lst` with 2 or 3 `nats`. If the `;-lst` contains only 2 terms, then a default value of 2020 is provided. This highlights an important aspect of mm-ADT's type system. Variables, types, and rewrites are all _graph search processes_. A defined type (path) with a desired *range* is searched for in the `obj` graph and returned if and only if the morphing `obj` matches the defined type's *domain*. Type definitions are simply other types that specify the means by which one type is translated into another type.

image::date-example.svg[]

[exec,none="",exception=LanguageException]
----
:[model,mm][define,nat<=int[is>0],                              %
                   date<=(nat[is=<12];nat[is=<31];nat),         %
                   date<=(nat[is=<12];nat[is=<31])[put,2,2020]]
(8;26;2020) => date
(8;26)      => date
----

===== Dependent Types

[exec,none=""]
----
:[model,mm][define,vec:(lst,int)<=lst-<(_,=(_)>-[count]),       %
                          single<=vec:(lst,is<4).0[tail][head], %
                          single<=vec:(lst,is>3).0[head]]
(1;2;3)   => vec                                               //<1>
(1;2;3)   => vec => single                                     //<2>
(1;2;3;4) => vec                                               //<3>
(1;2;3;4) => vec => single                                     //<4>
----
<1> A `;-lst` of 3 terms is morphed into a `vec` using the `vec\<=lst` type.
<2> The `vec` is morphed into a `single` using the first `single\<=vec` type.
<3> A `;-lst` of 4 terms is morphed into a `vec`.
<4> The `vec` is morphed into a `single` using the second `single\<=vec` type.

===== Recursive Types

A recursive type's definition contains a reference to itself. Recursive type definitions require a _base case_ to prevent an infinte recursion. Modern programming languages support generic collections, where a list can be defined to contain a particular type. For example, a `lst` containing only `ints`.


[exec,exception=LanguageException]
----
:[model,mm][define,xlist<=lst[[is,[empty]]|                  %
                              [[is,[head][a,str]];           %
                               [is,[tail][a,xlist]]]]]
( ) => [a,xlist]
('a';'b';'c') => [a,xlist]
('a';'b';'c') => xlist
(1;'a';'c') => xlist
('a';'b';'c') => xlist[put,0,3]
----

[exec,exception=LanguageException]
----
:[model,mm][define,ylist<=lst[[is,[empty]]|                  %
                              [[is,[head][a,str]];           %
                               [is,[tail][head][a,int]];     %
                               [is,[tail][tail][a,ylist]]]]]
( ) => [a,ylist]
('a';1;'b';2) => [a,ylist]
('a';1;'b';2) => ylist
(1;'a';'c') => ylist
('a';1;'b';2) => ylist[put,0,3]
----