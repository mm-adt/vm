:imagesdir: ./images/obj
:subs: non

== The Obj

.Products and Coproducts
****
https://en.wikipedia.org/wiki/Category_theory[Category theory] is the study of structure via https://en.wikipedia.org/wiki/Morphism[morphisms] that expose (or generate) other structures.
Two important category theoretic concepts dealing with substructures are *products* and *coproducts*.

image::product.svg[float="left",width=225]

A https://en.wikipedia.org/wiki/Product_(category_theory)[product] is any object defined in terms of it's accessible component objects.
That is, from a single object, via \$\pi_n\$ projection morphisms, the product is decomposed into it's constituent parts.

image::coproduct.svg[float="right",width=225]

A https://en.wikipedia.org/wiki/Coproduct[coproduct] is any object defined in terms of the component objects used to construct it.
That is, from many objects, via \$\iota_n\$ injection morphisms, a coproduct can be composed from constituent parts.

Along with these decomposition (and composition) morphisms, there exists an https://en.wikipedia.org/wiki/Isomorphism[isomorphism] between any two products (or coproducts) should they project (or inject) to the same component objects.
That is, product and coproduct equality are defined via component equality.
****

Everything that can be denoted in `mmlang` is an `obj`.
Within the VM and outside the referential purview of an interfacing language, every `obj` is the product of

image::obj-type-value-q.svg[float=left,width=375]

. an *object* that is either a *type object* or a *value object* and
. a *quantifier* specifying the "amount" of objects being denoted.

\[
\begin{split}
\text{ } \\ \texttt{obj} &= \texttt{object} &\;\times\; \texttt{q}
\text{ } \\ \texttt{obj} &= (\texttt{type object} + \texttt{value object}) &\;\times\; \texttt{q}.
\end{split}
\]

'''

image::obj-type-q-value-q.svg[float=right,width=375]

This internal structure is well-defined as an https://en.wikipedia.org/wiki/Ring_(mathematics)[algebraic ring].
The ring axioms specify how the internals of an `obj` are related via two binary operators: \$\times\$ and \$\+\$ . One particular axiom states that products both left and right https://en.wikipedia.org/wiki/Product_(category_theory)#Distributivity[distribute] over coproducts.
Thus, the previous formula is https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to


\[
\texttt{obj} = (\texttt{type object} \times \texttt{q}) + (\texttt{value object} \times \texttt{q}).
\]

There are two distinct kinds of mm-ADT `objs`: _quantified type objects_ and _quantified value objects_.
These products of the `obj` coproduct are called by simpler names: *type* and *value*.
That is the *obj meta-model*.

\[
\texttt{obj} = \texttt{type} + \texttt{value}
\]

NOTE: There are only a few instances in which it is necessary to consider the object component of an `obj` separate from its quantifier component.
The terms _type_ and _value_ will always refer to the object/quantifier-pair as a whole -- i.e., an `obj`.

[exec]
----
int              //<1>
1                //<2>
int{5}           //<3>
1{5}             //<4>
['a','b','a']    //<5>
----
<1> A single `int` type.
<2> A single `int` value of `1`.
<3> Five `int` types.
<4> Five `1` `int` values.
<5> A `str` *stream* composed of `'a'`,`'b'`, and `'a'` (definition forthcoming).

Both types and values can be operated on by types, where each is predominately the focus of either https://en.wikipedia.org/wiki/Compiler[compilation] (types) or https://en.wikipedia.org/wiki/Execution_(computing)[evaluation] (values).

* \$ (\tt{type} \times \tt{type}) \rightarrow \tt{type} \$: Used in https://en.wikipedia.org/wiki/Compiler[compilation] for https://en.wikipedia.org/wiki/Type_inference[type inferencing] and https://en.wikipedia.org/wiki/Rewriting[type rewriting], and
* \$ (\tt{value} \times \tt{type}) \rightarrow \tt{value} \$: Used in https://en.wikipedia.org/wiki/Computer_program[program] https://en.wikipedia.org/wiki/Execution_(computing)[evaluation] and as https://en.wikipedia.org/wiki/Anonymous_function[lambda functions].

[exec]
----
int => int[is,[gt,0]]                   //<1>
5 => int{?}<=int[is,bool<=int[gt,0]]    //<2>
----
<1> *Compilation*: The `int`-type is applied to the `int[is,[gt,0]]`-type to yield a https://en.wikipedia.org/wiki/Option_type[_maybe_] `int{?}`-type.
<2> *Evaluation*: The nested `bool\<=int[gt,0]`-type is a lamba function yielding `true` or `false`.

Some interesting conceptual blurs arise from the intermixing of types and values.
The particulars of the ideas in the table below will be discussed over the course of the documentation.

.Consequences of Type/Value Integration
[cols="2,2,13"]
|===
|structure A | structure B | unification

|type        | program    | a program is a "complicated" type.
|compilation | evaluation | compilations are https://en.wikipedia.org/wiki/Abstract_interpretation[type evaluations], where a compilation error is a "type runtime" error.
|type        | value      | quantifiers expand the cardinality of values and constrain the cardinality of types.
|type        | variable   | types refer to values across contexts and variables refer to values within a context.
|type        | https://en.wikipedia.org/wiki/Abstract_syntax_tree[AST]        | a single https://en.wikipedia.org/wiki/Intermediate_representation[intermediate representation] is used in compilation, optimization, and evaluation.
|type        | function   | functions are (https://en.wikipedia.org/wiki/Dependent_type[dependent]) types with values generated at evaluation.
|state       | trace      | types and values both encode state information in their process traces.
|classical   | quantum    | quantum computing is classical computing with a unitary matrix quantifier ring.
|===

=== The Type

.Cayley Graphs
****

image::compass.svg[width=300,float=right]

A https://en.wikipedia.org/wiki/Cayley_graph[Cayley graph] is a graphical encoding of a https://en.wikipedia.org/wiki/Group_(mathematics)[group].
If \$(A, \cdot, I)\$ is a group with carrier set \$A\$, binary operator \$\cdot : (A \times A) \to A\$, and https://en.wikipedia.org/wiki/Generating_set_of_a_group[generating set] \$I \subseteq A\$ then the https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)[graph] \$G = (V,E)\$ with vertices \$V = A\$ and labeled edges \$E = A \times I \times A\$ is the Cayley graph of the group.
The directed edge \$(a,i,b) \in E\$ written \$a \to_i b\$ states that the vertices \$a,b \in A\$ are connected by an edge labeled with the element \$i \in I\$.
Thus, \$a \to_i b\$ captures the group operation \$a \cdot i = b\$.

//In the illustrative example on the right, the group is defined \[
//\begin{split}
//A &= \{\uparrow,\nearrow,\to,\searrow,\downarrow,\swarrow,\leftarrow,\nwarrow \} \\ I &= \{ \nearrow \} \\ e &= 0^\circ \\ \cdot &: A \times A \rightarrow A \end{split}
//\]

When constructed in https://en.wikipedia.org/wiki/Eager_evaluation[full], a Cayley graph's vertices are the group elements and its edges represent the set of all possible \$I\$-transitions between elements.
When https://en.wikipedia.org/wiki/Lazy_evaluation[lazily] constructed, a Cayley graph encodes the history of a group computation, where the current element has an incoming \$I\$-edge from the previous element.
A Cayley graph captures both the https://en.wikipedia.org/wiki/Free_group[free] and non-free aspects of a group.
The non-free aspect is realized by any edge \$(a,i,b)\$ such that \$ai \mapsto b\$ and an element of the corresponding free algebra \$(A^\ast,\ast)\$ can be constructed by concatenating the edge labels of a path \$\prod_{e \in (a,i,b)^\ast} \pi_1(e)\$.

A _generalized_ Cayley graph does not require that every \$i \in I\$ have a corresponding \$i^{-1} \in I\$ such that \$i \cdot i^{-1} = \mathbf{1}\$ (i.e., multiplicative inverses).
By lifting this constraint, the Cayley graphical structure can be used to encode other https://en.wikipedia.org/wiki/Magma_(algebra)[magmas] such as https://en.wikipedia.org/wiki/Monoid[monoids] and https://en.wikipedia.org/wiki/Semigroup[semigroups].
****

An `obj` is either a type or a value:
\[
\texttt{obj} = \texttt{type}  + \texttt{value}.
\]

That equation is not an https://en.wikipedia.org/wiki/Axiom[axiom], but a https://en.wikipedia.org/wiki/Theorem[theorem].
Its truth can be deduced from the equations of the full https://en.wikipedia.org/wiki/Axiomatic_system[axiomatization] of `obj`.
In particular, for types, they are defined relative to other types.
Types are a coproduct of either a

. *canonical type* (ctype): a https://en.wikipedia.org/wiki/Primitive_data_type[base/fundamental] type, or a
. *derived type* (dtype): a product of a type and an https://en.wikipedia.org/wiki/Machine_code[instruction] (`inst`).

The ctypes are https://en.wikipedia.org/wiki/Nominal_type_system[nominal types].
There are five ctypes:

. *bool*: denotes the set of booleans -- \$ \mathbb{B} \$.
. *int*: denotes the set of integers -- \$ \mathbb{Z} \$.
. *real*: denotes the set of reals -- \$ \mathbb{R} \$.
. *str*: denotes the set of character strings -- \$ \Sigma^\ast \$.
. *poly*: denotes the set of polynomials (composites) -- \$ \tt{obj}^n \$.

image::type-product.svg[float=right,width=295]

The dtypes are https://en.wikipedia.org/wiki/Structural_type_system[structural types] whose https://en.wikipedia.org/wiki/Recursive_data_type[recursive definition]'s base case is a ctype realized via a chain of instructions (`inst`) that operate on types to yield types.
In other words, instructions are the https://en.wikipedia.org/wiki/Generating_set_of_a_group[generating set] of the type `objs`.
Formally, the type coproduct is defined as

\[
\begin{split}
\texttt{type} &=\;& (\texttt{bool} + \texttt{int} + \texttt{real} + \texttt{str} + \texttt{poly}) + (\texttt{type} \times \texttt{inst}) \\ \texttt{type} &=\;& \texttt{ctype} + (\texttt{type} \times \texttt{inst}) \\ \texttt{type} &=\;& \texttt{ctype} + \texttt{dtype}. \end{split}
\]


NOTE: Every `obj` has an associated quantifier.
When the typographical representation of an `obj` lacks an associated quantifier, the quantifier is https://en.wikipedia.org/wiki/Unit_(ring_theory)[unity].
For instance, the `real` `1.35{1}` is written more economically as `1.35`.

A dtype has two product projections.
The *type projection* denotes the https://en.wikipedia.org/wiki/Domain_of_a_function[domain] and the *instruction projection* denotes the https://en.wikipedia.org/wiki/Function_(mathematics)[function], where the type product as a whole, relative to the aforementioned component projections, is the https://en.wikipedia.org/wiki/Range_of_a_function[range].
\[
\begin{split}
\tt{type} &=\;& (\tt{type} &\;\times\;& \tt{inst}) &\;+\;& \tt{ctype} \\ \text{â€œrange} &=\;& (\text{domain} &\;\text{and}\;& \text{function}) &\;\text{or}\;& \text{base"} \end{split}
\]

The implication of the dtype product is that mm-ADT types are generated https://en.wikipedia.org/wiki/Inductive_type[inductively] by applying instructions from the mm-ADT VM's https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] (`inst`).
The application of an `inst` to a type (ctype or dtype) yields a dtype that is a structural expansion of the previous type.

image::ctype-dtype.svg[align=center,width=300]

For example, `int` is a ctype denoting a single `int` value from the set of all integers.
When `int` is applied to the instruction `[is>0]`, the dtype `int{?}\<=int[is>0]` is formed, where `[is>0]` is https://en.wikipedia.org/wiki/Syntactic_sugar[syntactic sugar] for `[is,[gt,0]]`.
This dtype is a https://en.wikipedia.org/wiki/Refinement_type[refinement type] that restricts `int` to only those `int` values greater than zero -- i.e., a natural number \$\mathbb{N}^+\$.
In terms of the "__range = domain and function__" reading, when an `int` (*domain*) is applied to `[is>0]` (*function*), the result is either an `int` greater than zero or no `int` at all (*range*).

image::int-isgt0.svg[align=center,width=230]

The diagram above is generally known as the *obj graph*.
The `obj` graph is a fundamental structure in mm-ADT that is used in https://en.wikipedia.org/wiki/Type_system#Type_checking[type checking], https://en.wikipedia.org/wiki/Type_inference[type inference], https://en.wikipedia.org/wiki/Optimizing_compiler[compiler optimization], https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)[garbage collection], and more.
This structure is called the *obj graph*.
The subgraph concerned with type definitions is called the *type graph*.
The subgraph considered with mutation history (https://en.wikipedia.org/wiki/State_(computer_science)[state]) is called the *value graph*.
The `obj` graph is a ringoid-link:https://en.wikipedia.org/wiki/Embedding[embedded] https://en.wikipedia.org/wiki/Monoidal_category[monoidal] https://en.wikipedia.org/wiki/Cayley_graph[Cayley graph].
This graph will be the subject of study throughout the documentation.

The full `obj` structure thus far is diagrammed on the right.
On the left are some example `mmlang` expressions.

image::obj-full.svg[float=right,width=300]

[exec]
----
int                                                         //<1>
int{2}                                                      //<2>
int{2}[is>0]                                                //<3>
int{2}[is>0][plus,[neg]]                                    //<4>
----
<1> A ctype denoting a single integer.
<2> A ctype denoting two integers.
<3> A dtype denoting zero, one, or two integers greater than 0.
<4> A dtype extending the previous type with negative integer addition.

==== Type Structure

The diagram below highlights the two primary components of a type, where an edge is denoted \$e=(a,i,b)\$.

. *Type signature*: the ctype specification of a type's domain and range.
. *Type definition*: a domain rooted instruction sequence terminating at the range.

image::type-signature-definition.svg[align=center,width=650]

===== Type Signature

Every mm-ADT type can be generally understood as a https://en.wikipedia.org/wiki/Function_(mathematics)[function] that maps an `obj` of one type to an `obj` of another type.
A *type signature* specifies the source and target of this mapping, where the *domain* is the source type, and the *range* is the target type.
In `mmlang` a type signature has the following general pattern where `{q}` is the ctype's associated quantifier.

[.center]
[width=30]
|===
^a|
[exec,eval=false,exception=LanguageException]
----
range{q}<=domain{q}
----
{blank}
|===

NOTE: In common mathematical vernacular, if the function \$f\$ has a domain of \$X\$ and a range of \$Y\$, then it's signature is denoted \$f: X \to Y\$.
Furthermore, given quantifiers from a ring \$Q\$, the function signature would be denoted \$f: X \times Q \to Y \times Q\$ or \$f: (X \times Q) \to (Y \times Q)\$.

[cols="6,10"]
|===
|mmlang Expression |Description

<.^a|
[exec]
----
int<=int
----
{blank}
|From the perspective of "_type-as-function_," An mm-ADT `int` is a https://en.wikipedia.org/wiki/NOP_(code)[no-op] on the set of integers. Given any integer, `int` returns that integer. In `mmlang`, when the domain and range are the same, the `\<=` and repeated type are not displayed. That is `int\<=int` is more concisely displayed as `int`.

<.^a|
[exec]
----
int{1}
int
----
{blank}
|In most programming languages, a value can be typed `int` as in

`val x:int = 10`.

Such https://en.wikipedia.org/wiki/Declaration_(computer_programming)[declarations] state that the value referred to by `x` is a _single_ element within the set of integers. The concept of a "single element" is captured in mm-ADT by the `obj` quantifier, where a https://en.wikipedia.org/wiki/Unit_(ring_theory)[unit] quantifier is not displayed in `mmlang`. That is, `int{1}` is more concisely displayed as `int`.

<.^a|
[exec]
----
int{5}
----
{blank}
|`int{5}` is a type referring to 5 integers. As a point of comparison, `int{1}` refers to a single integer with a syntax sugar of `int` in `mmlang`.

<.^a|
[exec]
----
int{0,5}
int{0,5}<=int{0,5}
----
{blank}
|Quantifiers must be elements from a ring with unity. In the previous examples, the quantifier ring was \$(\mathbb{Z}, +,\ast)\$. In this example, the quantifier ring is \$(\mathbb{Z} \times \mathbb{Z}, +,\ast)\$, where the https://en.wikipedia.org/wiki/Algebraic_structure[carrier set] is the set of all pairs of integers and addition and multiplication operate pairwise,
\[
(a,b) \cdot (c,d) \mapsto (a \cdot c,b \cdot d).
\]
The type `int{0,5}` denotes either 0, 1, 2, 3, 4, or 5 integers. In general, this quantifier ring represents uncertainty as to the number of elements being referred to.

<.^a|
[exec,exception=LanguageException]
----
int<=bool
----
{blank}
|Types that are fully specified by their type signature are always canonical types. Therefore, `bool\<=int` is meaningless as there are no instructions to map an `int` to a `bool`. This example does not assume an underlying _model_. With model-ADTs, it is possible for `bool\<=int` to yield a result.

|===

===== Type Definition

.Commuting Diagrams
****
https://en.wikipedia.org/wiki/Category_theory[Category theory] is a branch of abstract algebra that studies algebraic structures via their homomorphic image within a https://en.wikipedia.org/wiki/Many-sorted_logic[multi-sorted] monoid called a *category*.
A category is defined as \[
(\mathbf{A},\circ,\mathbf{1}_\mathbf{A}), \]
where \$\mathbf{A}\$ is a set of _morphisms_, \$\mathbf{A}(A)\$ is an _object_ morphism simply denoted \$A\$, \$circ: \mathbf{A}(A,B) \times \mathbf{A}(B,C) \to \mathbf{A}(A,C) \$ is an associative, binary, morphism composition operator, and for every \$A\$, there is an identity morphism \$\mathbf{1}_A \in \mathbf{1}_\mathbf{A}\$ such that \$A \circ \mathbf{1}_A = A = \mathbf{1}_A \circ A\$.
Unlike classical monoids, a category's \$\circ\$ operator is generally not https://en.wikipedia.org/wiki/Closure_(mathematics)[closed].
That is, there are compositions which may not be defined.
It is this aspect of a category that makes it a _multi-sorted_ (or typed) monoid.

image::commuting-diagram.svg[float=right,width=150]

In a manner analogous to Cayley graphs, category theory has https://en.wikipedia.org/wiki/Diagram_(category_theory)[diagrams].
If \$f:A \to B \in \mathbf{A}(A,B)\$ and \$g: B \to C \in \mathbf{A}(B,C)\$, then there exists the morphism path \[
A \xrightarrow{f} B \xrightarrow{g} C. \]
A https://en.wikipedia.org/wiki/Commutative_diagram[commutative diagram] is one such that every morphism path starting at the same source and ending at the same destination is equal.
Thus, if \$g \circ f = i \circ h\$, then it is said that the associated diagram _commutes_.
****

Types and values both have a *ground* that exists outside of the mm-ADT virtual machine within the hosting environment (e.g. the https://en.wikipedia.org/wiki/Java_virtual_machine[JVM]).
The ground of the mm-ADT value `2` is the JVM primitive `2L` (a Java `long`).
The ground of the mm-ADT type `int` is the JVM class `java.lang.Long`.
When the instruction `[plus,4]` is applied to the mm-ADT `int` value `2`, a new mm-ADT `int` value is created whose ground is the JVM value `6L`.
When `[plus,4]` is applied to the mm-ADT `int` type, a new type is created with the same `java.lang.Long` ground.
Thus, the information that distinguishes `int` from `int[plus,4]` is in the reference to the instruction that was applied to `int`.

For a type, the deterministic chain of references is called the *type definition* and is encoded as a https://en.wikipedia.org/wiki/Path_(graph_theory)[path] in the *type graph*.
For a value, the *value graph* encodes an analogous path called the *value history* (or _mutation history_).
Both types and values exist in a larger graph called an *obj graph* such that \[
G_{\texttt{obj}} = G_{\texttt{type}} \cup G_{\texttt{value}}.
\]
The https://en.wikipedia.org/wiki/Commutative_diagram[commutative diagram] below denotes an `obj` graph composed of two lateral paths.
The top path is a value history (\$(2 \to 6 \to 6)\$ and the bottom path is a type definition \$(\tt{i\nt} \to \tt{i\nt[plus,4]} \to \tt{i\nt[plus,4][is>0]})\$.
These paths are joined by the only instruction in `inst` that unites the type graph and value graph, \[
\texttt{[type]}: \texttt{obj} \to \texttt{type}.
\]

NOTE: In practice, the string representation of a value is its _ground_ and the string representation of a type is its _path_.

[cols="7,9"]
|===
a|
[exec]
----
2[plus,4][is>0]
2[plus,4][is>0][path]
2[plus,4][is>0][type]
----
{blank}
|image:type-value-path.svg[]
|===

In theory, the complete history of an mm-ADT program (from compilation to execution) is stored in the `obj` graph.
However, in practice, the mm-ADT VM removes paths once they are no longer required by the program.
This process is called *path retraction* and is the mm-ADT equivalent of https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)[garbage collection].

NOTE: image:type-value-path-short.svg[float=right,width=350] In the diagram above, the type vertices are elements of a https://en.wikipedia.org/wiki/Free_algebra[free algebra] called the `inst` monoid.
However, in order to present more complex https://en.wikipedia.org/wiki/Commutative_diagram[diagrams], vertex labels will be shortened to the type's canonical range type.
With this convention, there is no loss of information.
The full definition can be unambiguously determined by concatenating the instructions encountered on the edges of the inverted path from the current _range_ vertex to the root _domain_ vertex (i.e. the base canonical type of the type induction).
Furthermore, https://en.wikipedia.org/wiki/Commutative_diagram#Arrow_symbols[_hook-tailed_] arrows will replace `[type]`-labeled arrows as they denote a https://en.wikipedia.org/wiki/Monomorphism[monomorphic] https://en.wikipedia.org/wiki/Embedding[embedding].
All subsequent diagrams will follow this convention.

.The Obj Graph as a Cayley Graph and a Commutative Diagram
================================================================
The `obj` graph is both the generalized https://en.wikipedia.org/wiki/Cayley_graph[Cayley graph] of a https://en.wikipedia.org/wiki/Partial_function[partial] https://en.wikipedia.org/wiki/Monoid[monoid] and the https://en.wikipedia.org/wiki/Commutative_diagram[commutative diagram] of a https://en.wikipedia.org/wiki/Free_category[free category].
More generally, the `obj` graph is the https://en.wikipedia.org/wiki/Function_(mathematics)#Representing_a_function[graph of unary functions] comprising `inst`, where instructions operate on both types and values.
From compilation to evaluation, depending on the particular context, either interpretation will be leveraged.

* *Commutative diagram*: vertices denote type/value-objects of the `obj` category with `inst` morphisms.

The `obj` graph's commuting property eases compile-time and runtime https://en.wikipedia.org/wiki/Graph_rewriting[type rewriting].
If two paths have the same source vertex (domain) and target vertex (range), then both paths yield the same result (the target vertex).
In practice, evaluating the instructions along the https://en.wikipedia.org/wiki/Computational_complexity_theory[computationally cheaper] path is prudent.

* *Cayley graph*: vertices denote type/value-elements of the `inst` monoid with generating edges in `inst`.

As a generalized, multi-rooted monoidal Cayley graph, the set of all possible mm-ADT computations is theoretically predetermined given the https://en.wikipedia.org/wiki/Presentation_of_a_monoid[monoid presentation] containing the root `objs` (e.g. the ctypes), its generators (`inst`), and relations (https://en.wikipedia.org/wiki/Equivalence_relation[path equations]).
This static immutable structure serves as a https://en.wikipedia.org/wiki/Memoization[memoization] of computational results.
This is especially useful when considering *streams* (definition forthcoming) and their role in data-intensive, cluster-oriented environments where storage is cheap and processors are costly.
================================================================

===== Type Quantification

.Initial and Terminal Objects
****
A category may have an https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial and/or terminal] object.

'''
image::initial.svg[width=125,float=left]

An *initial object* \$S\$ is the domain of a set of morphism \$S \rightarrow E_n\$.
Initial objects, via their morphisms, generate all the objects of the category.
If there is an initial object, then it is unique in that if there is another initial object, it has the same diagrammatic topology -- all outgoing morphisms and no incoming morphisms save the identity.
Thus, besides labels, two initials are isomorphic.

'''

image::terminal.svg[width=125,float=right]

A *terminal object* \$E\$ is the range of a set of morphisms \$S_n \rightarrow E\$.
Terminal objects subsume all other objects in the category in that all other objects \$S_n\$ can be morphed into the terminal object, but the terminal object can not be morphed into any other object.
Similar to initials, should another terminal exist, the two terminal are isomorphic in that they both have the same number of incoming morphisms and no outgoing morphisms (save the identity).

&nbsp;
****

In order to quantify the _amount_ of values denoted by a type, every mm-ADT type has an associated *quantifier* \$q \in Q\$ denoted `{q}` in `mmlang`, where \$Q\$ is the carrier of an ordered algebraic https://en.wikipedia.org/wiki/Ring_(mathematics)[ring with unity] (e.g. integers, reals in \$ \mathbb{R}, \mathbb{R}^2, \mathbb{R}^3, \ldots, \mathbb{R}^n \$, https://en.wikipedia.org/wiki/Unitary_matrix[unitary matrices], etc.).
Typically, integer quantifiers signify "amount." However, other quantifiers such as unitary matrices used in the representation of a https://en.wikipedia.org/wiki/Wave_function[quantum wave function], "amount" is a less accurate description as quantifiers can be negative such that `objs` interact with constructive and destructive https://en.wikipedia.org/wiki/Wave_interference[interference].

The default *quantifier ring* of the mm-ADT VM is \[
(\mathbb{Z} \times \mathbb{Z}, +, \ast), \]
where \$(0,0)\$ is the additive identity and \$(1,1)\$ is the multiplicative identity (https://en.wikipedia.org/wiki/Unit_(ring_theory)[unity]).
The \$ +\$ and \$\ast\$ binary operators perform pairwise integer addition and multiplication, respectively.
In `mmlang` if an `obj` quantifier is not displayed, then the quantifier is assumed to be the unity of the ring, or `{1,1}`.
Moreover, if a single value is provided, it is assumed to be repeated, where `{n}` is shorthand for `{n,n}`.
Thus, \[
\texttt{int} \equiv \texttt{int\{1\}} \equiv \texttt{int\{1,1\}}.
\]

One quantifier serves an important role in mm-ADT as both the additive identity and multiplicative https://en.wikipedia.org/wiki/Annihilator_(ring_theory)[annihilator] -- `{0}`.
All `objs` quantified with the respective quantifier ring's annihilator are https://en.wikipedia.org/wiki/Isomorphism[isomorphic] to the https://en.wikipedia.org/wiki/Initial_and_terminal_objects[initial object].

[exec,none=""]
----
6{0}
int{0}[plus,2]
int[plus,2]{0}
_{0}
obj{0}
----

NOTE: Types such as `int{0}` and `int{0}\<=int[is,false]` are equivalent due to their quantifiers both being `{0}`.
Throughout the documentation, all zero quantified `objs` will be referred to as `obj{0}`, `_{0}`, or \$\underline{\mathbf{0}}\$ (the *zero object*).

Quantifiers serve an important role in https://en.wikipedia.org/wiki/Type_inference[type inference] and determining, at compile time, the expected cost of a particular type definition (i.e., an instruction sequence).
The table below itemizes common quantifier patterns along with names the are typically used in programming languages.

[.center]
[cols="^1h,1,1,3,9",width=80]
|===
| name | sugar | unsugared | description  | mmlang example

| some |       | `{1,1}`  | a single `int`  a|
[exec]
----
int
----
{blank}
| option | `{?}` | `{0,1}` | 0 or 1 `int`  a|
[exec]
----
int{?}<=int[is>0]
----
{blank}
| none | `{0}` | `{0,0}` | 0 `ints`  a|
[exec]
----
int{0}<=int[is,false]
----
{blank}
| exact | `{4}` | `{4,4}` | 4 `ints`  a|
[exec]
----
int{4}<=int{2}[_,_]
----
{blank}
| any | `{*}` | `{0,max}`  | 0 or more `ints`  a|
[exec]
----
int{*}<=rec{*}[get,'age',int]
----
{blank}
| given  | `{+}` | `{1,max}`  | 1 or more `ints` a|
[exec]
----
int{+}
----
{blank}
|===

Types use quantifiers in two separate contexts: *type signatures* and *type definitions*.

[discrete]
====== Type Signature Quantification

A type signature's _domain_ specifies the type and quantity of the `obj` required for evaluation.
The _range_ denotes what can be expected in return. `int{6}\<=int{3}` states that given `3` `ints`, the type will return `6` `ints`.
Quantifiers in a type signature are descriptive, used in https://en.wikipedia.org/wiki/Type_system#Static_type_checking[type checking].

[exec,exception=LanguageException]
----
4 => int{6}<=int{3}[[plus,1],[plus,1]]
4{3} => int{6}<=int{3}[[plus,1],[plus,1]]
[4,5,6] => int{6}<=int{3}[[plus,1],[plus,1]]
[4{2},5{1},6{2}] => int{6}<=int{3}[[plus,1],[plus,1]]
[4{2},5{-1},6{2}] => int{6}<=int{3}[[plus,1],[plus,1]]
----

Much will be said about negative quantifiers.
For now, note that negative quantifiers enable https://en.wikipedia.org/wiki/Lazy_evaluation[lazy], stream-based https://en.wikipedia.org/wiki/Set_theory[set theoretic] operations such as intersection, union, difference, etc.
Extending beyond integer quantification \$(\mathbb{Z})\$, negative quantifiers enable constructive and destructive interference in https://en.wikipedia.org/wiki/Quantum_computing[quantum computating] \$(\mathbb{C})\$ and excitatory and inhibitory activations in https://en.wikipedia.org/wiki/Artificial_neural_network[neural computing] \$(\mathbb{R})\$.

[discrete]
====== Type Definition Quantification

A type definition's _instructions_ can be quantified.
More specifically, a type's intermediate dtypes can be quantified.
During https://en.wikipedia.org/wiki/Type_inference[type inference], the quantifier ring's \$(+\$/\$\ast)\$-operators propagate the quantifiers through the types that compose the program.

[exec]
----
int{3}[[plus,1],[plus,1]]              //<1>
int{3}[plus,1]{2}                      //<2>
----
<1> Given `3` `ints`, `[plus,1]` will be evaluated (in parallel) `2` twice.
The result is `6` `ints`.
<2> The instruction `[plus,1]{2}` is the merging of two `[plus,1]` _branches_.

At https://en.wikipedia.org/wiki/Compiler#Middle_end[type compilation], the https://en.wikipedia.org/wiki/Branch_(computer_science)[branch] optimizer "collapses" _type object_ equivalent branches with no effect to the results.
The branches' _type quantifiers_ are added using the quantifier ring's \$+\$-operator (the quantifier group).
Once collapsed, quantifiers can be moved left-or-right using the quantifier ring's multiplicative \$\ast\$-operator due to the _commutativity of quantifiers theorem_ (the quantifier monoid).
It is more efficient (especially as branches grow in complexity) to compute \$2b\$ than \$b + b\$.

[.center]
[cols=".^1,5",width=65,frame=none,grid=none]
|===

|
\[
\begin{split}
a(b+b)c &= a(2b)c \\
&= a2bc   \\
&= 2abc
\end{split}
\]
| image:branch-q-addition.svg[align=center,width=500]
|===

The following two examples highlight the fact that type signature quantifiers are used for https://en.wikipedia.org/wiki/Type_system#Static_type_checking[type checking] and type definition quantifiers are used for https://en.wikipedia.org/wiki/Type_inference[type inference].

[.center]
[cols="4,2",width=80]
|===
a|
[exec,exception=LanguageException]
----
4{3} => [[plus,1],[plus,1]]
4{3} => int{6}<=int{3}[[plus,1],[plus,1]]
4{2} => int{6}<=int{3}[[plus,1],[plus,1]]
----
{blank}
<|
\[
\begin{split}
\texttt{int\{q\}}
&= 3 \ast (1 + 1) \\
&= (3 \ast 1) + (3 \ast 1) \\
&= 3 + 3 \\
&= 6
\end{split}
\]

a|
[exec,exception=LanguageException]
----
4{3} => [plus,1]{2}
4{3} => int{6}<=int{3}[plus,1]{2}
4{2} => int{6}<=int{3}[plus,1]{2}
----
{blank}
<|
\[
\begin{split}
\texttt{int\{q\}}
&= 3 \ast 2 \\
&= 6
\end{split}
\]
|===

===== Type Evaluation

[cols=1,width=20,float=right,grid=none,frame=none]
|====
|
\[
\big[ m_0 \ast m_1 \ast \ldots \ast m_n \big]
\begin{bmatrix}
g_0  \\ + \\ g_1 \\ + \\ \vdots \\ + \\ g_n
\end{bmatrix} \left\| \oplus r \right\rangle
\big[ \ast \ldots \ast \big]
\begin{bmatrix}
+ \\ \vdots \\ + \\
\end{bmatrix} \ldots
\]
|====

The mm-ADT virtual machine has two layers of logic: the https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture] and the https://zenodo.org/record/2565243[stream ring]. The instructions specify how input `objs` are mapped to output `objs`. Instruction composition is subject to the axioms (and entailed theorems) of the stream ring and its three operators: \$\ast\$, \$ +\$, and \$\oplus\$. The stream ring's multiplicative https://en.wikipedia.org/wiki/Monoid[monoid's] \$\ast\$-operator concatenates *serial streams*, the additive https://en.wikipedia.org/wiki/Abelian_group[abelian group's] \$ +\$-operator arranges *parallel streams*, and the stream https://en.wikipedia.org/wiki/Near-ring[near-ring's] non-commutative group's \$\oplus\$-operator https://en.wikipedia.org/wiki/Fold_(higher-order_function)[reduces] streams down to a *singleton stream*.

[.small]
[cols="1,1,2",width=20,float=left]
|====
| sugar  | op            | inst

| `\=>`  | \$\ast\$      | `[juxta]`
| `[ ]`  | \$ +\$        | `[branch]`
| `=\|`  | \$ \oplus\$   | `[barrier]`
|====

The illustration above is an intuitive visualization of an mm-ADT type from the perspective of monoidal, group, and near-ring magmas interacting with one another in a series (\$\ast\$) of expansions (\$ +\$) and contractions (\$ \oplus\$), where \$m_i,g_i,r \in \tt{obj}\$. The mm-ADT instruction set architecture has three https://en.wikipedia.org/wiki/Higher-order_function[higher-order instructions] providing direct access to the three stream ring operators. It is through these instructions that the other instructions are grounded in the underlying algebra of the mm-ADT VM -- https://zenodo.org/record/2565243[the stream ring].

The primary distinguising characteristic of the three aforementioned *stream instructions* is that they are no preserved in the `obj` graph. Their purpose is to compose instructions, not _be_ instructions. However, it is for this reason that processing can be detached from the `obj` graph, working a level below the instruction set architecture and directly at the stream ring level.

[cols="4,7"]
|====
^| `\=>` ^| `[ ]`

a|
[exec]
----
6 => 8 => 10
6[map,8][map,10]
6 => 8 => 10 => [path]
6[map,8][map,10][path]
----
{blank}

a|
[exec]
----
6[+1,+2]+3
6-<(+1,+2)>-+3
6[+1,+2]+3[path]
6-<(+1,+2)>-+3[path]
----
{blank}
|====


[cols="7,2",float=right,frame=none,grid=none]
|====

| mm-ADT instructions are curried https://en.wikipedia.org/wiki/Unary_function[unary functions].
For instance, the instruction `[neg]` takes an input `int` and outputs the inverse (or negative) `int`. Thus, `[neg]` behaves as its classic unary function counterpart
\[
\texttt{neg}(x) = -x,
\]
where `5\=>int[neg]` maps to `-5`.


a|
[exec]
----
5=>int[neg]
5=>-5
-5
----
{blank}
|====

[cols="7,3",float=right,frame=none,grid=none]
|====

| Next, suppose the https://en.wikipedia.org/wiki/Binary_function[binary function]
\[
\texttt{plus\}(x,y) = x + y.
\]
In mm-ADT, a particular evaluation may be expressed as `6\=>[plus,2]`. Given that the instruction has a https://en.wikipedia.org/wiki/Constant_function[constant] value argument of \$2\$, `[plus,2]` acts in a manner analogous to a https://en.wikipedia.org/wiki/Currying[curried] unary function.

a|
[exec]
----
6=>int[plus,2]
6=>int[plus,[6=>2]]
6=>8
8
----
{blank}
|====

[cols="7,5",float=right,frame=none,grid=none]
|====

| If the argument to `[plus]` is a type (as opposed to a value), then the argument's value resolution is https://en.wikipedia.org/wiki/Dependent_type[dependent] on the incoming `obj`. For instance, if `int[plus,[mult,2]]` has an incoming `int` of 6, the argument to `[plus]` is 12.

a|[exec]
----
6=>int[plus,[mult,2]]
6=>int[plus,[6=>[mult,2]]]
6=>int[plus,[6=>[mult,[6=>2]]]]
6=>int[plus,[6=>[mult,2]]]
6=>int[plus,12]
6=>18
18
----
{blank}
|====


[cols="7,5",float=right,frame=none,grid=none]
|====

| However, if the incoming `int` is 8, then the `[plus]` argument is 16. Thus, while mm-ADT can be understood as the serial and parallel composition of unary functions, function behavior via types, can be made dependent on the state of the incoming `obj`.


a|[exec]
----
8=>int[plus,[mult,2]]
8=>int[plus,[8=>[mult,2]]]
8=>int[plus,[8=>[mult,[8=>2]]]]
8=>int[plus,[8=>[mult,2]]]
8=>int[plus,16]
8=>24
24
----
{blank}
|====

'''

==== Type System

[cols="^1,4,9"]
|===
| type      | description | mmlang example

| https://en.wikipedia.org/wiki/Anonymous_function[anonymous] | A type with an unspecified domain.
a|
[exec]
----
5 => [plus,2]
5 => [plus,[plus,2]]
----
{blank}

| https://en.wikipedia.org/wiki/Monomial[monomial] | A https://en.wikipedia.org/wiki/Primitive_data_type[primitive type] that is a single term and coefficient.
a|
[exec,exception=LanguageException]
----
5   => int
'5' => int
5   => int{10}
----
{blank}
| https://en.wikipedia.org/wiki/Polynomial[polynomial] | A https://en.wikipedia.org/wiki/Composite_data_type[composite type] containing a linearly combination of terms and their coefficients.
a|
[exec,exception=LanguageException]
----
(+{2}3,+{3}4,+{4}5)
5-<(+{2}3,+{3}4,+{4}5)
5-<(+{2}3,+{3}4,+{4}5)>-[sum]
----
{blank}
| https://en.wikipedia.org/wiki/Refinement_type[refinement] | A subset of another type.
a|
[exec,exception=LanguageException,none=""]
----
:[define,nat<=int[is>0]]
5 => nat
0 => nat
----
{blank}
| https://en.wikipedia.org/wiki/Recursive_data_type[recursive] | A type with components of the same type.
a|
[exec,exception=LanguageException,none=""]
----
:[define,list<=[(_){?}\|(_,list)]]
(1)             => list
(1,(1))         => list
(1,(1,(1)))     => list
(1,(1,(1,(1)))) => list
1               => list
(1,1)           => list
----
{blank}
| https://en.wikipedia.org/wiki/Dependent_type[dependent] | A type with a definition variable to the incoming `obj`.
a|
[exec,none=""]
----
5 => [is>int]
5 => [plus,int]
----
{blank}
| https://en.wikipedia.org/wiki/Category_(mathematics)[model] | A set of types and path equations.
a|
[exec,exception=LanguageException,none=""]
----
:[model,social:('type'->  %
  (person -> (person:('name'->str,'age'->nat)), %
   nat    -> (nat<=int[is>0])))]
('name'->'marko','age'->0)                => person
('name'->'marko','age'->29)               => person
('name'->'marko','age'->29,'alive'->true) => person

----
{blank}
|===

===== Anonymous Types

The type `bool\<=int[gt,10]` has a *range* of `bool` and a *domain* of `int`. When the type is written without it's range as `int[gt,10]`, the range is deduced. The `int` domain ctype is applied to `[gt,10]` to yield a `bool`. A type with an unspecified range is called an an *anonymous type* and is denoted `_` in `mmlang` (or with no character in many situations). An anonymous range is the result of an anonymous domain.

[cols="5,5"]
|===
^| `_` range ^| `_` domain

a|
[exec]
----
bool<=int[gt,10]      //<1>
_<=int[gt,10]         //<2>
int[gt,10]            //<3>
_
----
<1> The domain and range of the type are fully specified.
<2> A type with a specified domain of `int` and a specified range of `_`.
<3> An `mmlang` sugar where if no range is specified, and it differs from the domain, then `_` is assumed.

a|
[exec]
----
int{?}<=int[is,bool<=int[gt,10]]     //<1>
int[is,int[gt,10]]                   //<2>
int[is,_[gt,10]]                     //<3>
int[is,[gt,10]]                      //<4>
----
<1> The domain and range of the outer and inner nested type are fully specified.
<2> The nested type has a specified domain of `int`.
<3> The nested type has an unspecified domain of `_`.
<4> An `mmlang` sugar where if no domain is specified, `_` is assumed.
|===


[cols="8,.^8",grid=none,frame=none]
|===

| In the *anonymous type* `\_{2}[plus,1]{3}[gt,0]`, the `[plus]` instruction is https://en.wikipedia.org/wiki/Polymorphism_(computer_science)[polymorphic], but `[gt]` isn't. Thus, the anonymous type's range can be deduced, but without a domain ctype, the internal dtype is also unknown. When `int{2}` is provided, it triggers a cascade of deductions that determines incident types of the instructions in the `obj` graph. The quantifier ring, when moving "horizontally" across the multiplicative `inst` monoid alters quantifiers using its multiplication operator, where \$2 \ast 3 \ast 1 = 6\$. Thus, `bool{6}\<=int{2}[plus,1]{3}[gt,0]`
a|
[exec]
----
_{2}[plus,1]{3}[gt,0][explain]
----
{blank}
a|
[exec]
----
int{2}[plus,1]{3}[gt,0][explain]
----
{blank}
|
image:anon-example.svg[width=400,align=center]
|===


[discrete]
====== Anonymous Type Uses

Anonymous types are useful in other situations besides https://en.wikipedia.org/wiki/Type_inference[lazy typing] expressions.

[exec]
----
5-<(_,_)                               //<1>
-5[is>0 -> +2 | _ -> +10]              //<2>
5-<([a,int],[a,_],[a,str])             //<3>
----
<1> When no processing is needed on a split, `_` should be provided.
<2> When used in a `|-rec` `poly`, `_` is used to denote the https://en.wikipedia.org/wiki/Switch_statement[default case].
<3> `5` is both an `int` and a `_`, but not a `str`.

In general, anonymous types are https://en.wikipedia.org/wiki/Pattern_matching#Primitive_patterns[wildcards] because they https://en.wikipedia.org/wiki/Matching_wildcards[pattern match] to every `obj`. As will be demonstrated soon, when a *variable* is specified (e.g. `[plus,x]`) or a new type is specified (e.g. `x:42`), The `x` is a *named anonymous type*. The entailment of this is that types and variables are in the same https://en.wikipedia.org/wiki/Namespace[namespace].

===== Mono Types

[cols="1,4,1,1",width=40%,float=right]
|===
| type | inst                              | 0       |  1

| `bool` | `&&` `\|\|` `-` `!`             | `false` | `true`
| `int`  | `*` `+` `-` `>` `<` `>=` `=<`  | `0`     | `1`
| `real` | `*` `+` `-` `>` `<` `>=` `=<`  | `0.0`   | 1.0
| `str`  | `+` `>` `<` `>=` `=<`          | `''`    |
|===

The mm-ADT type system can be partitioned into *mono types* (https://en.wikipedia.org/wiki/Monomial[monomials]) and *poly types* (https://en.wikipedia.org/wiki/Polynomial[polynomials]). There are 4 mono types, each denoting a classical https://en.wikipedia.org/wiki/Primitive_data_type[primtive] data type: `bool`, `int`, `real`, and `str`. The associated table presents the typical operators (https://en.wikipedia.org/wiki/Syntactic_sugar[sugared] instructions) that can be applied to each mono type. The table also includes their respective additive \$(\mathbf{0})\$ and multiplicative \$(\mathbf{1})\$ https://en.wikipedia.org/wiki/Identity_element[identities].

A few of the more interesting aspects of the mono types are detailed in the following subsections.

[discrete]
====== Zero and One

The instructions `[zero]` and `[one]` are https://en.wikipedia.org/wiki/Constant_function[constant] polymorphic instructions. Each provides a unique singleton value associated with the type of the respective incoming `obj`.

[exec,exception=LanguageException]
----
(bool[zero],int[zero],real[zero],str[zero])
(true,6,5.5,'ryan')=([zero],[zero],[zero],[zero])
(bool[one],int[one],real[one])
(true,6,5.5)=([one],[one],[one])
'ryan'[one]
----

Each type's \$\mathbf{0}\$ and \$\mathbf{1}\$ value serves as the `[plus]` and `[mult]` instruction identities, respectively. Furthermore, for those types that form a https://en.wikipedia.org/wiki/Ring_(mathematics)[ring with unity], the `[zero]` is their respective multiplicative https://en.wikipedia.org/wiki/Annihilator_(ring_theory)[annihilator].
////
[exec]
----
(true,6,5.5,'ryan')>-[plus,[zero]]
(true,6,5.5)>-[mult,[one]]
(true,6,5.5)>-[mult,[zero]]
----
////
===== Poly Types

mm-ADT types are either https://en.wikipedia.org/wiki/Monomial[monomials] or https://en.wikipedia.org/wiki/Polynomial[polynomials]. The components of a polynomial are called *terms*. A term is the product of a *variable* and a *coefficient*. If \$X\$ is a set of variables and \$Q\$ a set of coefficients, then a polynomial is the https://en.wikipedia.org/wiki/Linear_combination[linear combinations]  of \$Q \times X\$ elements typically written
\[
q_1x_1 + q_2x_2 + \ldots + q_nx_n.
\]
An mm-ADT type is the product of an *object* (variable) and a *quantifier* (coefficient) -- e.g., `int{3}`. When types are linearly combined, they form a `poly`. The mm-ADT `poly` respects the ring-theoretic polynomial axioms and in doing so, realizes all entailed polynomial theorems.

[.text-center]
`(x1{q1},x2{q2},...,xn{qn})`

At first glance, the `poly` structure denoted above appears to be some sort of https://en.wikipedia.org/wiki/Collection_%28abstract_data_type%29[collection] data structure. When the terms of a `poly` are values, the `poly` is a https://en.wikipedia.org/wiki/Multiset[multiset] (or bag). However, when the terms are types, the entire corpus of polynomial theory is immediately applicable to `poly`. The fundamental insight that confers numerous benefits is that mm-ADT, as an algebraic ring structure itself, can be faithfully https://en.wikipedia.org/wiki/Embedding[embedded] in mm-ADT `poly`. This enables collection-oriented https://en.wikipedia.org/wiki/Metaprogramming[meta-programming], a unification of products and coproducts as https://en.wikipedia.org/wiki/Biproduct[biproducts], the integration of data https://en.wikipedia.org/wiki/Data_structure[structures] and https://en.wikipedia.org/wiki/Control_flow[flow control] processes, and the development of compilers and execution engines based on centuries old https://en.wikipedia.org/wiki/Factorization_of_polynomials[polynomial factorization] techniques.

This section will present the practical aspects of `poly` with a forthcoming section detailing the `poly` algebra which is founded on https://en.wikipedia.org/wiki/Polynomial_ring[polynomial ring] and https://en.wikipedia.org/wiki/Module_(mathematics)[module] theory.

[discrete]
====== Poly Structures

There are *value* `polys` and there are *type* `polys`. A value `poly` is composed of only value `objs` and is best understood as a https://en.wikipedia.org/wiki/Collection_%28abstract_data_type%29[collection] data structure. A type `poly` must contain at least one non-\$\mathbf{0}\$ `obj` (i.e. `obj{0}`) and is intuitively understood as https://en.wikipedia.org/wiki/Stream_processing[streaming] process.

As a practical consideration, mm-ADT offers two kinds of `poly`: `lst` (https://en.wikipedia.org/wiki/List_(abstract_data_type)[list]) and `rec` (https://en.wikipedia.org/wiki/Record_%28computer_science%29[record]), where theoretically, `rec` is simply a `lst` with some added conveniences that reduce the semantic and syntactic complexity of various common use cases. Finally, every `poly` has one of three forms: `,`, `;`, or `|`. The mm-ADT `poly` data type is captured by the following equation and diagram.

\[
\begin{split}
\texttt{poly} &= \texttt{lst} &+ \texttt{rec} \\ \texttt{poly} &= (\texttt{,-lst} + \texttt{|-lst} + \texttt{;-lst}) &+ (\texttt{,-rec} + \texttt{|-rec} + \texttt{;-rec}).
\end{split}
\]

'''

image:poly-kinds.svg[width=350,float=left]

[cols="1,1,3,3,3",width=50,float=right]
|===
| poly     ^| sep  | access     | value | type

.3+.^| `lst` ^| `,`  | all
| https://en.wikipedia.org/wiki/Multiset[multiset]
| https://en.wikipedia.org/wiki/Union_(set_theory)[union]
^|  `;` | last
| https://en.wikipedia.org/wiki/List_(abstract_data_type)[list]
| https://en.wikipedia.org/wiki/Method_chaining[chain]
^| `\|` | head
| https://en.wikipedia.org/wiki/Scalar_(mathematics)[scalar]
| https://en.wikipedia.org/wiki/Null_coalescing_operator[coalesce]
.3+.^| `rec` ^| `,`  | all match
| https://en.wikipedia.org/wiki/Multimap[multimap]
| https://en.wikipedia.org/wiki/Method_cascading[cascade]
^| `;`  | last match
| https://en.wikipedia.org/wiki/Associative_array[record]
| https://en.wikipedia.org/wiki/Conditional_(computer_programming)[condition]
^| `\|` | first match
| https://en.wikipedia.org/wiki/Tuple[pair]
| https://en.wikipedia.org/wiki/Switch_statement[switch]
|===

'''

====== Poly Collections

A `poly` can be used a https://en.wikipedia.org/wiki/Collection_%28abstract_data_type%29[collection] data structure. There are a total of 6 sorts of collections as there are two kinds of `poly` (`lst` and `rec`) and each kind has 3 forms (`,`,`;`,`|`). The forms determine the *ambient algebra* associated with the collection. These algebras are manifestations of particular magmas of the underlying algebra of mm-ADT: a https://en.wikipedia.org/wiki/Ring_(mathematics)[ring] with unity maintaining a left https://en.wikipedia.org/wiki/Module_(mathematics)[R-module].

[cols="^1h,4,9,^1h,4,9"]
|===
| lst | collection | mmlang example | rec | collection | mmlang example

| `,` | https://en.wikipedia.org/wiki/Abelian_group[abelian group] +
https://en.wikipedia.org/wiki/Multiset[multiset]
a|
[exec,prompt="mm> "]
----
('a'{?},'b','a','b')
('a'{?},'b','a','b')>-
----
{blank}
| `,` | https://en.wikipedia.org/wiki/Abelian_group[abelian group] +
https://en.wikipedia.org/wiki/Multimap[multimap]
a|
[exec,prompt="mm> "]
----
('a'->1,'b'->2,'a'->3)
('a'->1,'b'->2,'a'->3)>-
----
{blank}
| `;` | https://en.wikipedia.org/wiki/Monoid[monoid] +
https://en.wikipedia.org/wiki/List_(abstract_data_type)[list]
a|
[exec,prompt="mm> "]
----
('a';'b';'a';'b')
('a';'b';'a';'b')>-
----
{blank}
| `;` | https://en.wikipedia.org/wiki/Monoid[monoid] +
https://en.wikipedia.org/wiki/Associative_array[record]
a|
[exec,prompt="mm> "]
----
('a'->1;'b'->2;'a'->3)
('a'->1;'b'->2;'a'->3)>-
----
{blank}
| `\|` | https://en.wikipedia.org/wiki/Near-ring[near-ring] +
https://en.wikipedia.org/wiki/Scalar_(mathematics)[scalar]
a|
[exec,prompt="mm> "]
----
('a'\|'b'\|'a'\|'b')
('a'\|'b'\|'a'\|'b')>-
----
{blank}
| `\|` | https://en.wikipedia.org/wiki/Near-ring[near-ring] +
https://en.wikipedia.org/wiki/Tuple[pair]
a|
[exec,prompt="mm> "]
----
('a'->1\|'b'->2\|'a'->3)
('a'->1\|'b'->2\|'a'->3)>-
----
{blank}
|===

.,-poly Collections
The *,-polys* capture the additive https://en.wikipedia.org/wiki/Abelian_group[abelian group] of the mm-ADT ring, where the carrier set is `obj` and the https://en.wikipedia.org/wiki/Commutative_property[commutative] binary operator is `,`. Being commutative, the terms are unordered. Moreover, given quantification, should two `,-poly` terms have equal _objects_, they can be merged using the mm-ADT \$+\$-operator equation of
\[
a_{q_0} + b_{q_1} =
\begin{cases}
  a_{q_0 + q_1}     & \text{if } a == b, \\
  a_{q_0} + b_{q_1} & \text{otherwise},
\end{cases}
\]
such that when two term objects are not equal, the `poly` is https://en.wikipedia.org/wiki/Irreducible_representation[irreducible]. Given the lack of order along with quantifier "weighting," `,-lst` collections realize https://en.wikipedia.org/wiki/Multiset[multiset] semantics (also known as bags or weighted sets). `,-rec` collections realize https://en.wikipedia.org/wiki/Multimap[multimap] semantics which are https://en.wikipedia.org/wiki/Associative_array[associative arrays] that support multiple values for a single key.

.;-poly Collections
The *;-polys* capture the non-commutative, multiplicative https://en.wikipedia.org/wiki/Monoid[monoid] of the mm-ADT ring. Due to non-commutativity, the `;` delimited terms form an https://en.wikipedia.org/wiki/Sequence[ordered sequence]. In `lst`, the consequence is collection data structure with https://en.wikipedia.org/wiki/List_(abstract_data_type)[list]-semantics. In `rec`, an ordered https://en.wikipedia.org/wiki/Record_%28computer_science%29[record] is realized.

.|-poly Collections
The *|-polys* capture the non-commutative additive group of the mm-ADT https://en.wikipedia.org/wiki/Near-ring[near-ring]. A forthcoming section detailing mm-ADT's ring algebra will discuss the *reduce near-ring*. For now, note that the `|-poly` collections yield singleton `lsts` and `recs`. As such, the `|-polys` are less useful as collections than as controls.

NOTE: When each `poly` kind (`lst` or `rec`) contains 0 or 1 term, their behavior's are equivalent. It is only at 2+ terms that their respective algebras are discernible and instructions such as `[eq]` consider the `poly` term separator in their calculation.


====== Poly Controls

The mm-ADT ring's additive https://en.wikipedia.org/wiki/Abelian_group[abelian group] operator is accessible via the `[branch]` instruction. The `[branch]` instruction's argument is a `poly`. Each term of the `poly` argument is an operand of the ring's \$+\$-operator. In this way, each of the 6 `poly` forms represents a particular https://en.wikipedia.org/wiki/Control_flow[control structure]. Due to the prevalent use of `[branch]`, `mmlang` offers the sugar'd encoding of `[ ]`, where both the instruction opcode and the `poly` parentheses are not written. For example, `[branch,(+1,+2,+3)]` is equivalent to `[+1,+2,+3]`.

[cols="^1h,3,9,^1h,3,9"]
|===
| lst | control | mmlang example | rec | control | mmlang example

| `,` | https://en.wikipedia.org/wiki/Union_(set_theory)[union] +
https://en.wikipedia.org/wiki/Method_cascading[cascade]

a|
[exec,prompt="mm> "]
----
6 => int[+1,+3,+1]
----
{blank}
| `,` | https://en.wikipedia.org/wiki/Conditional_(computer_programming)[conditional] +
https://en.wikipedia.org/wiki/Method_cascading[cascade]

a|
[exec,prompt="mm> "]
----
6 => int[is>10 -> +1, %
         is>5  -> +2, %
         int   -> +3]
----
{blank}
| `;` | https://en.wikipedia.org/wiki/Fluent_interface[fluent] +
https://en.wikipedia.org/wiki/Method_chaining[chaining]
a|
[exec,prompt="mm> "]
----
6 => int[+1;+2;+3]
----
{blank}
| `;` | https://en.wikipedia.org/wiki/Conditional_(computer_programming)[conditional] +
https://en.wikipedia.org/wiki/Method_chaining[chaining]
a|
[exec,prompt="mm> "]
----
6 => int[is>0 -> +1; %
         is>5 -> +2; %
         int  -> +3]
----
{blank}
| `\|` | https://en.wikipedia.org/wiki/Null_coalescing_operator[coalesce]
a|
[exec,prompt="mm> "]
----
6 => int[+1[is>10]\| %
         +2[is>5] \| %
         +3       ]
----
{blank}

| `\|` | https://en.wikipedia.org/wiki/Switch_statement[switch]
a|
[exec,prompt="mm> "]
----
6 => int[is>10 -> +1\| %
         is>5  -> +2\| %
         _     -> +3]
----
{blank}
|===
'''

.,-poly Controls
The *,-polys* capture the additive https://en.wikipedia.org/wiki/Abelian_group[abelian group] of the mm-ADT ring. The https://en.wikipedia.org/wiki/Associative_property[associativity] and https://en.wikipedia.org/wiki/Commutative_property[commutativity] of the group operator means that the order in which the terms are evaluated (associativity) and results aggregated (commutativity) does not change the semantics of the computation. More specifically to the notion of control, it means that the irreducible terms in a `,-poly` are not sequentially dependent on one another. This independence enables evaluation isolation and thus, promotes https://en.wikipedia.org/wiki/Parallel_computing[parallelism]. The `,-poly` algebra realizes https://en.wikipedia.org/wiki/Method_cascading[cascading] https://en.wikipedia.org/wiki/Union_(set_theory)[union] in `lst` and https://en.wikipedia.org/wiki/Conditional_(computer_programming)[conditional] cascading in `rec`.

Note that in all subsequent `[branch,poly]` equations to follow, \$x \in \tt{obj}\$ is an incoming `obj` to the respective `[branch]` instruction.


[cols="^3,^4"]
|====
| ,-lst (union cascade) | ,-rec (conditional cascade)

|
\[
x => \big[v_0,v_1,\ldots,v_n\big] \;\;=\;\; \coprod_{i=0}^n x => v_i
\]
|
\[
x => \big[[k_0,v_0],\ldots,[k_n,v_n]\big]
\;\;=\;\;
\coprod_{i=0}^n
\begin{cases}
x => v_i   & \text{if } (x => k_i) \neq \mathbf{0}, \\
\mathbf{0} & \text{otherwise}.
\end{cases}
\]
|====

.;-poly Controls
The *;-polys* capture the multiplicative https://en.wikipedia.org/wiki/Monoid[monoid] of the mm-ADT ring. The result of each term is the input to the next term in the sequence. In `lst`, https://en.wikipedia.org/wiki/Method_chaining[method chaining] is realized and in `rec` https://en.wikipedia.org/wiki/Conditional_(computer_programming)[conditional] chaining.

[cols="^3,^4"]
|====
| ;-lst (fluent chaining) | ;-rec (conditional chaining)

|
\[
x => \big[v_0;v_1;\ldots;v_n\big] \;\;=\;\; x => \prod_{i=0}^n v_i
\]

|
\[
x => \big[[k_0,v_0],\ldots,[k_n,v_n]\big]
\;\;=\;\;
x => \prod_{i=0}^n
\begin{cases}
v_i   & \text{if } (x => k_i) \neq \mathbf{0}, \\
\mathbf{0} & \text{otherwise}.
\end{cases}
\]
|====

.|-poly Controls
The *|-polys* capture the non-commutative group of mm-ADT's _reduce_ https://en.wikipedia.org/wiki/Near-ring[near-ring] (explanation forthcoming), where the first non-\$\mathbf{0}\$ ("non-link:https://en.wikipedia.org/wiki/Null_pointer[null]") element is the output of the branch. As a control structure, `|-poly` is a https://en.wikipedia.org/wiki/Sequential_algorithm[sequential] branch that can be understood programmatically as a https://en.wikipedia.org/wiki/Short-circuit_evaluation[short-circuit] https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29[fold]. In `lst`, https://en.wikipedia.org/wiki/Null_coalescing_operator[non-null coalescing] is realized and in `rec` a https://en.wikipedia.org/wiki/Switch_statement[switch statement] is realized.

[cols="^3,^4"]
|====
| \|-lst (coalesce) | \|-rec (switch)

|
\[
x => \big[v_0,v_1,\ldots,v_n\big] =
\begin{cases}
x => v_0  & \text{if } (x => v_0) \neq \mathbf{0}, \\
x => v_1  & \text{if } (x => v_1) \neq \mathbf{0}, \\
\ldots  & \\
x => v_n  & \text{if } (x => v_n) \neq \mathbf{0}, \\
\mathbf{0} & \text{otherwise}.
\end{cases}
\]
|
\[
x => \big[[k_0,v_0],\ldots,[k_n,v_n]\big]
=
\begin{cases}
x => v_0  & \text{if } (x => k_0) \neq \mathbf{0}, \\
x => v_1  & \text{if } (x => k_1) \neq \mathbf{0}, \\
\ldots  & \\
x => v_n  & \text{if } (x => k_n) \neq \mathbf{0}, \\
\mathbf{0} & \text{otherwise}.
\end{cases}
\]
|====

NOTE: As previously stated for collection `polys`, control `poly` semantics are only discernible amongst `polys` with 2 or more terms.

====== Poly Lifting

image:poly-lift.svg[float=left,width=250] A consequence of the dual use of `poly` as both a data structure and a control structure is that `poly` supports a https://en.wikipedia.org/wiki/Lift_(mathematics)[lifted] encoding of mm-ADT itself. Each `poly` form captures a particular https://en.wikipedia.org/wiki/Magma_%28algebra%29[magma] of the underlying mm-ADT stream ring algebra. As a collection, `poly` provides a programmatic way of writing mm-ADT programs (types) and as flow control, these `poly` encoded mm-ADT programs can be executed. The complete algebraic specification of `poly` lifting via an `obj`-link:https://en.wikipedia.org/wiki/Module_(mathematics)[module] of the mm-ADT ring will be presented in a latter section. For now, the following `mmlang` examples demonstrate `poly` lifting in support of mm-ADT https://en.wikipedia.org/wiki/Metaprogramming[metaprogramming].

The mm-ADT type below contains both monoidal (serial composition) and group (parallel branching) components whose construction is captured by the bottom morphism of the diagram above. Note that the `[explain]` instruction is appended for educational purposes only -- so as to detail the \$\Rightarrow\$ compositions.

image::poly-embed-composition.svg[width=220,align=center]

[exec]
----
int{3}[mult,10][is>20 -> [+70,+170,+270], %
                is>10 ->   [*10,*20,*30]][plus,100][explain]
----


The above type can be expressed in a pure `poly` form, where `;` is serial composition and `,` is parallel branching. This construction is captured by the slanted morphism in the diagram above.

image::poly-embed-lifting.svg[width=220,align=center]

[exec]
----
(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270)>-)>-, %
                     -<([is>10];-<(*10,*20,*30  )>-)>-)>-;[plus,100])
----

The `[split]` instruction (sugar'd `-<`) renders `poly` a ring https://en.wikipedia.org/wiki/Module_(mathematics)[module]. Incoming `objs` are https://en.wikipedia.org/wiki/Scalar_(mathematics)[scalars] to a `poly` https://en.wikipedia.org/wiki/Vector_space[vector] according to the equations
\[
\begin{split}
x \prec &\; (v_0,v_1,\ldots,v_n) \;\;&=\;\; (xv_0,xv_1,\ldots,xv_n) \\
x \prec &\; (v_0;v_1;\ldots;v_n) \;\;&=\;\; (xv_0;v_1;\ldots;v_n)   \\
x \prec &\; (v_0|v_1|\ldots|v_n) \;\;&=\;\; (xv_i),
\end{split}
\]
where \$x \prec \tt{poly}\$ is the instruction `x \=> [split,poly]`. The `[merge]` instruction evaluates the `poly` according to the algebra denoted by its term separator (`,`, `;`, or `|`). This has the effect of "draining" the `poly` of it's internal `objs` such that
\[
\begin{split}
(xv_0,xv_1,\ldots,xv_n) \succ \;\;&=\;\; \coprod_{i=0}^n x \Rightarrow v_i \\
(xv_0;v_1;\ldots;v_n)   \succ \;\;&=\;\; x \Rightarrow \prod_{i=0}^n v_i  \\
(xv_i)                  \succ \;\;&=\;\; xv_i : v_i \neq \mathbf{0},
\end{split}
\]
where \$\tt{poly} \succ\$ is the expression `poly \=> [merge]`.

Finally, both the original unlifted form and the `poly` lifted form of the type yield the same result at evaluation, where the final expression binds (`-<`) the values 1, 2, and 3 to the indeterminate terms, thus solving (`>-`) the https://en.wikipedia.org/wiki/Polynomial_ring[polynomial] equation.

image::poly-embed-solve.svg[width=220,align=center]

[exec]
----
[1,2,3] => int{3}[mult,10][is>20 -> [+70,+170,+270], %
                           is>10 ->   [*10,*20,*30]][plus,100]
[1,2,3]-<(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270)>-)>-, %
                              -<([is>10];-<(*10,*20,*30  )>-)>-)>-;[plus,100])>-
----

Given that `[split,poly:x][merge]` is equivalent to `[branch,poly:x]`, the `poly` type can be written more succinctly in a pure `[branch]` form as below.

[exec]
----
[1,2,3] => [int{3};[mult,10];[[[is>20];[+70,+170,+270]], %
                              [[is>10];[*10,*20,*30  ]]];[plus,100]]
----

Note that, when incident to each other, `[split]/[merge]` has the same equation as `[branch]`.

\[
\begin{split}
x \prec &\; (v_0,v_1,\ldots,v_n) \succ \;\;&=\;\; x \Rightarrow \big[v_0,v_1,\ldots,v_n \big] \;\;&=\;\; \coprod_{i=0}^n x \Rightarrow v_i  \\
x \prec &\; (v_0;v_1;\ldots;v_n) \succ \;\;&=\;\; x \Rightarrow  \big[v_0;v_1;\ldots;v_n\big] \;\;&=\;\; x \Rightarrow \prod_{i=0}^n v_i   \\
x \prec &\; (v_0|v_1|\ldots|v_n) \succ \;\;&=\;\; x \Rightarrow \big[v_0|v_1|\ldots|v_n\big]  \;\;&=\;\; xv_i : v_i \neq \mathbf{0}
\end{split}
\]

The reason for using `-<( )>-` versus `[ ]` is that when `[split]` and `[merge]` are not juxtaposed, https://en.wikipedia.org/wiki/Reflection_(computer_programming)[reflection] is possible on the intermediate results of the internal `poly` computation. That is, when only a `[split]` is applied, a _half-branch_ occurs and all the `poly` domain instructions can operate on the midway results. Intuitively, `[split]` transforms a control structure into a data structure and `[merge]` transforms a data structure into a control structure. At this intermediate point when the computation is a data structure, the computation can be manipulated programmatically. That is the power of a lifted representation.

[exec]
----
[1,2,3]-<(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270))))
[1,2,3]-<(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270)),     %
                              -<([is>10];-<(*10,*20,*30  ))))
[1,2,3]-<(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270)>-)>-, %
                              -<([is>10];-<(*10,*20,*30  )>-)>-)>-;[plus,100])
[1,2,3]-<(int{3};[mult,10];-<(-<([is>20];-<(+70,+170,+270)>-)>-, %
                              -<([is>10];-<(*10,*20,*30  )>-)>-)>-;[plus,100])>-
----

In summary, mm-ADT can be https://en.wikipedia.org/wiki/Embedding[embedded] in `poly` itself. The formal proof of this fact demonstrates that the mm-ADT https://en.wikipedia.org/wiki/Instruction_set_architecture[instruction set architecture], the two https://en.wikipedia.org/wiki/Ring_%28mathematics%29[ring] operators (\$+\$ and \$*\$), and the _reduce_ https://en.wikipedia.org/wiki/Near-ring[near-ring] operator (\$\oplus\$) are sufficiently expressive to yield a https://en.wikipedia.org/wiki/Turing_completeness[Turing Complete] computing machine.

===== Refinement Types

https://en.wikipedia.org/wiki/Refinement_type[Refinement types] extend a language's base types with https://en.wikipedia.org/wiki/Predicate_(mathematical_logic)[predicates] that further _refine_ (constrain) the base type values. A classic example is the set of natural numbers (\$\mathbb{N}\$) as a refinement of the set of integers (\$\mathbb{Z}\$), where \$\mathbb{N} \subset \mathbb{Z}\$. In https://en.wikipedia.org/wiki/Set-builder_notation#Sets_defined_by_a_predicate[set builder notation], specifying the set of integers and a predicate to limit the set to only those integers greater than 0 is denoted
\[
\mathbb{N} = \{n \in \mathbb{Z} \;|\; n > 0\}.
\]
In mm-ADT, the above is denote `int[is>0]` which is the sugar form of `int{?}\<=int[is,[gt,0]]`. mm-ADT supports user defined types. In fact, mm-ADT's primary goal is a way to elegantly express types, mappings between them such that data structures can be viewed from different algebraic and domain perspectives. The `[define]` instruction defines a type within the current context (i.e. the current type nest level). In a forthcoming section on _model-ADTs_, the more general `[model]` instruction will be presented.

.mm-ADT Prefix Type
================================================================
All `mmlang` examples with a `:type` expression are defining a *prefix type*. This type is prefixed to all subsequent expressions. In many ways, a prefix type is like an https://en.wikipedia.org/wiki/Assembly_language#Assembler[assembler] https://en.wikipedia.org/wiki/Object_file[object file]. On the other hand, model-ADTs (of `[model]`) are similar to the `import` of https://en.wikipedia.org/wiki/Class_(computer_programming)[class files] in https://en.wikipedia.org/wiki/Object-oriented_programming[object-oriented languages].
================================================================

[exec,none="",exception=LanguageException]
----
:[define,nat<=int[is>0]]
10 => nat
-1 => nat
10 => nat[plus,5]
10 => nat[plus,5][plus,-15]
----

[discrete]
====== Poly Refinement

There are two canonical `poly` types: `lst` and `rec`. Any restriction on their respective values is a *refinement*. The example below defines a `date` to be a `;-lst` with 2 or 3 `nats`. If the `;-lst` contains only 2 terms, then a default value of 2020 is provided. This highlights an important aspect of mm-ADT's type system. Variables, types, and rewrites are all _graph search processes_. A defined type (path) with a desired *range* is searched for in the `obj` graph and returned if and only if the morphing `obj` matches the defined type's *domain*. Type definitions are simply other types that specify the means by which one type is translated into another type.

image::date-example.svg[]

[exec,none="",exception=LanguageException]
----
:[define,nat<=int[is>0],                             %
        date<=(nat[is=<12];nat[is=<31];nat),         %
        date<=(nat[is=<12];nat[is=<31])[put,2,2020]]
(8;26;2020) => date
(8;26)      => date
----

===== Dependent Types

[exec,none=""]
----
:[define,vec:(lst,int)<=lst-<(_,=(_)>-[count]),       %
                single<=vec:(lst,is<4).0[tail][head], %
                single<=vec:(lst,is>3).0[head]]
(1;2;3)   => vec                                    //<1>
(1;2;3)   => vec => single                          //<2>
(1;2;3;4) => vec                                    //<3>
(1;2;3;4) => vec => single                          //<4>
----
<1> A `;-lst` of 3 terms is morphed into a `vec` using the `vec\<=lst` type.
<2> The `vec` is morphed into a `single` using the first `single\<=vec` type.
<3> A `;-lst` of 4 terms is morphed into a `vec`.
<4> The `vec` is morphed into a `single` using the second `single\<=vec` type.

===== Recursive Types

A recursive type's definition contains a reference to itself. Recursive type definitions require a _base case_ to prevent an infinte recursion. Modern programming languages support generic collections, where a list can be defined to contain a particular type. For example, a `lst` containing only `ints`.


[exec,exception=LanguageException]
----
:[define,xlist<=lst[[is,[empty]]|                  %
                    [[is,[head][a,str]];           %
                     [is,[tail][a,xlist]]]]]
( ) => [a,xlist]
('a';'b';'c') => [a,xlist]
('a';'b';'c') => xlist
(1;'a';'c') => xlist
('a';'b';'c') => xlist[put,0,3]
----

[exec,exception=LanguageException]
----
:[define,ylist<=lst[[is,[empty]]|                  %
                    [[is,[head][a,str]];           %
                     [is,[tail][head][a,int]];     %
                     [is,[tail][tail][a,ylist]]]]]
( ) => [a,ylist]
('a';1;'b';2) => [a,ylist]
('a';1;'b';2) => ylist
(1;'a';'c') => ylist
('a';1;'b';2) => ylist[put,0,3]
----



=== The Obj Graph

An mm-ADT program is a type. The `mmlang` parser converts a textual representation of a type into a type `obj`. The mm-ADT VM encodes a type `obj` as a https://en.wikipedia.org/wiki/Path_(graph_theory)[path] within a larger *type graph* (a Cayley graph). While a path in the type graph is a graphical encoding of the ring structure of a type, it is also a specification of a data flow https://en.wikipedia.org/wiki/Pipeline_(computing)[pipeline] that when evaluated, realizes elements of the type (i.e. computed resultant values). These values also have a graphical encoding in a larger *value graph*. Together, the type graph and the value graph form the `obj` graph.

Every aspect of an mm-ADT computation from composition, to compilation, and ultimately to evaluation is materialized in the `obj` graph. The following itemization details the role of the `obj` graph across various stages of a computation.

* *Composition*: The construction of a type via the https://en.wikipedia.org/wiki/Tacit_programming[point-free] style of `mmlang` is a the lexical correlate of walking the `obj` graph from a source vertex (domain ctype) across a series of instruction-labeled edges (`inst`) to ultimately arrive at a target vertex (range ctype).
* *Compilation*: A path in the type graph can be prefixed with another ctype (e.g. `_` to `int`). In doing so, the path is recomputed to yield a variant path.
* *Rewrite*: Subpaths of a path in the type graph can be specied as being semantically equivalent to another path in the type graph via `poly` lifted rewriting `(y)\<=(x)`. Subsequent compilations and evaluations of the path will yield variants.
* *Optimization*: Every instruction in `inst` has an associated cost. Rewrites create a superposition of programs. Given that the `obj` graph https://en.wikipedia.org/wiki/Commutative_diagram[commutes], a https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm[weighted shortest path] calculation from a domain vertex to a range vertex is a simple technique for choosing an efficient execution plan.
* *Variables*: Variable bindings are encoded in instructions. When the current instruction being evaluated requires historic state information, the `obj`^op^ graph (with edges reversed) is searched in order to locate the vertex incident to a variable `inst`.
* *Evaluation*: Program evaluation binds the type graph to the value graph. When a type path is prefixed with a value `obj`, the instructions along the path operate on the value, where the path's target vertex is the result of the computation.

This section will discuss the particulars of the aforementioned uses of the `obj` graph.

==== State

Let \$(M,\cdot,e)\$ be a https://en.wikipedia.org/wiki/Monoid[monoid], where \$e \in M\$ is the https://en.wikipedia.org/wiki/Identity_element[identity element] and there exists an element \$e' \in M\$ that also acts as an identity such that for every \$ x \in M \$, \$x \cdot e = x\$ and \$x \cdot e' = x\$, then because \$e \cdot e' = e\$ and \$e \cdot e' = e'\$, it is the case that \$e = e \cdot e' = e'\$ and \$e = e'\$.
Thus, every monoid has a *single unique identity*.
However, in a https://en.wikipedia.org/wiki/Free_monoid[free monoid], where element composition history is preserved, it is possible to record \$e\$ and \$e'\$ as distinctly _labeled_ elements even though their role in the non-free monoid's binary composition are the same -- namely, that they both act as identities.

It is through *multiple distinct identities* in `inst` that mm-ADT supports the programming idioms below.

[cols="3,1,1,4" width=65%]
|===
| idiom                                                                      | inst         | sugar | description

| https://en.wikipedia.org/wiki/Variable_%28computer_science%29[variables]   | `[to]`       | `< >` | nominal `obj` references
| https://en.wikipedia.org/wiki/Data_type[type definitions]                  | `[define]`   |       | user defined types
| https://en.wikipedia.org/wiki/Rewriting[rewrite rules]                     | `[rewrite]`  |       | type equivalences
|===


In particular, state stored in the path history of the `obj`.

[exec]
----
6 => int[plus,[mult,2]][path]
8 => int[plus,[mult,2]][path]
----

Every `obj` exists as a distinct vertex in the `obj` graph.
If \$b \in \tt{obj}\$ has an incoming edge labeled \$i \in \tt{i\nst}\$, then when applied to the outgoing adjacent vertex \$a\$, \$b\$ is computed.
Thus, the edge \$a \to_i b\$ records the instruction and incoming `obj` that yielded the `obj` at the head of the edge.
The `obj` at the tail of the edge may also have incoming edges in the `obj` graph.
Inductively, these edges can be followed back to root such that the aggregation of the traversed vertices and edges is a *path*.
The computational path of an `obj` is accessed via `[path]`.
The output of `[path]` is a `;-lst` that can be https://en.wikipedia.org/wiki/Reflection_(computer_programming)[introspected] as any other `lst`.

[exec]
----
8 => int[plus,1][mult,2][lt,63]                        //<1>
8 => int[plus,1][mult,2][lt,63][path]                  //<2>
8 => int[plus,1][mult,2][lt,63][path][get,5][get,0]    //<3>
----
<1> The evaluation of an `bool\<=int` type via 8.
<2> The `obj` graph path from 8 to `[lt,63]`.
<3> A projection of the instruction `[lt,63]` from the path and then the first argument of the `inst`.

mm-ADT leverages a collection of *distinct identity instructions*, such that as instructions, they simply compute \$f(x) \mapsto x\$, but as edge labels in the `obj` Cayley graph, they store state information that can be later accessed via trace-based path analysis.
In effect, the execution context is transformed from a memory-less https://en.wikipedia.org/wiki/Finite-state_machine[finite state automata] to a https://en.wikipedia.org/wiki/Processor_register[register]-based https://en.wikipedia.org/wiki/Turing_machine[Turing machine].

===== Variables

image::linear-variable-example.svg[align=center,width=600]

[exec]
----
9 => int[plus,1]<x>[plus,2][mult,x]         //<1>
9 => int[plus,1]<x>[plus,2][mult,x][path]   //<2>
int[plus,1]<x>[plus,2][mult,x][explain]     //<3>
----
<1> The `<x>` instruction stores the value `10` in the value's path through the `obj` graph.
<2> The `[path]` instruction provides the automaton's path through the `obj` graph as `;-lst`.
<3> The `[explain]` instruction details the scope of state variables.

The scope of a variable starts at the moment of declaration (`[to]`) and ends when the declaring branch is complete.
If an `inst` has a type argument, that type has access to the variables declared in any parent branch.

[exec,exception=LanguageException]
----
2 => int<x>[plus,<y>][plus,y]                                                      //<1>
2 => int<x>[plus,[plus,x]<x>[plus,x]][plus,x]                                      //<2>
2 => int<x>[plus,[plus,x]<x>[plus,x]][plus,x][path]                                //<3>
int<x>[plus,int<y>[plus,int<z>[plus,x][plus,y][plus,z]][plus,y]][plus,x][explain]  //<4>
----
<1> The variable `y` is declared in a branch nested within the retrieving branch.
<2> The variable `x` is redefined in the nested branch and recovers its original value when the nested branch completes.
<3> The value path of the previous evaluation highlighting that the final `[plus,x]` resolved to `[plus,2]`.
<4> A multi-nested expression demonstrating the creation and destruction of variable scope.

===== Definitions

===== Rewrites

Each step of that walk is an instruction forming an edge in the type graph.
For instance, the type

[.text-center]
`int[is,[eq,int]]`

describes a https://en.wikipedia.org/wiki/Reflexive_relation[reflexive graph] with vertices are in `int` and edges labeled `[is,[eq,int]]`.
There are other mm-ADT types (an infinite amount in fact) that are related to `int[is,[eq,int]]` by a https://en.wikipedia.org/wiki/Graph_homomorphism[graph homomorphism].
A few such types are itemized below.

[source]
----
int[plus,0]
int[mult,1]
int[plus,1][plus,-1]
int[plus,2][plus,-2]
int[plus,3][plus,-3]
...
----

Note a common pattern.
The type `int[plus,x:int][plus,x:int[neg]]` captures an infinite number of more specific types that are homomorphic to `int[is,[eq,int]]`. https://en.wikipedia.org/wiki/Higher-order_function[Higher order type] are defined using mm-ADT `polys`.

[.text-center]
`(int[is,[eq,int]])\<=(int[plus,x:int][plus,x:int[neg]])`

In category theory, a _type-to-type_ mapping that https://en.wikipedia.org/wiki/Morphism[preserves structure] is called a https://en.wikipedia.org/wiki/Functor[functor].
From the perspective of mm-ADT, two new "ctypes" are linked in a domain/range `\<=`-relation within a higher-order https://en.wikipedia.org/wiki/Identity_function[identity type] with respective signature.
The identity is apparent in that there are no instructions required to coerce an `obj` of the domain to an `obj` of the range.
This is analogous to `int\<=int`, save that the mapping is not predicated on https://en.wikipedia.org/wiki/Isomorphism[isomorphism], but on a broader relationship called a https://en.wikipedia.org/wiki/Surjective_function[surjective] homomorphism (a  https://en.wikipedia.org/wiki/Rewriting[reduction]).
Any type containing only a type signature `()\<=()` says that the domain type is equal to the range type such that the domain can be https://en.wikipedia.org/wiki/Abstract_rewriting_system[substituted] for the range.

[source]
----
[define,(int[is,[eq,int]])<=(int[plus,x][plus,x[neg]])][int][plus,10][plus,-10]
----

image::type-to-type-type.png[width=700,align=center]

The type `int[is,[eq,int]]` has an https://en.wikipedia.org/wiki/Isomorphism[isomorphic] image in `int`, where the reflexive self-loop paths in `int[is,[eq,int]]` are contracted to 0-length paths.
The isomorphism realizes `int` as a classic set without structure because the type `int` has no instructions and thus, no type graph edges.

[source]
----
mmlang> [define,int<=(int[is,[eq,int]])]
        [define,(int[is,[eq,int]])<=(int[plus,x:int][plus,x:int[neg]])]
        [int][plus,10][plus,-10]
==>int
----

The composition of two structure preserving type morphisms yields a new type--namely, `int\<=(int[plus,x:int][plus,x:int[neg]])`.

==== Models

mm-ADT organizes types into *models*.
The 4 _mono_ types (`bool`,`int`,`real`,`str`) and the 2 _poly_ types (`lst`, `rec`) are defined in a model called `mm` (the _mm_ of mm-ADT).
The `mm` *model-ADT* is the canonical model by which all other models are derived.
Much like ctypes and dtypes, `mm` can be understood as a "cmodel" and all derived models as "dmodels" (though these terms are not used beyond this section).
While model-ADT design and development will be discussed in a latter section, this section introduces the `[define]` instruction and it's use as an identity type.

* `[define]`: Associates a type with a range composed of an object _token_ and a quantifier.
* `[as]`: Locates the first type definition capable of mapping the incoming `obj` to the token argument.

[exec,none="",exception=LanguageException]
----
[define,nat<=int[is>0]]                            //<1>
int => [define,nat<=int[is>0]]                     //<2>
 6  => [define,nat<=int[is>0]][as,nat]             //<3>
-6  => [define,nat<=int[is>0]][as,nat]             //<4>
----
<1> An identity `inst` that associates the token `nat` as the unit (`{1}`) range of `int[is<0]]`.
<2> `mmlang` does not display `[define]` instructions in a type's `inst` `obj` graph path.
<3> `[as]` searches the `obj` graph for a `nat<=int` type definition and evaluates the mapping.
<4> The definition requires `nat` be `\_{1}` but `-6` is `_{0}`.

With a large number of definitions, expression such as the following become untenable from a usability perspective.

[exec,eval=false]
----
('name'->'marko','age'->29)  => [define,nat<=int[is>0],person<=('name'->str,'age'->nat)][as,person]
----

For this reason, there is the `[model]` instruction which can be globally defined as the first instruction of ctype and thus, rooted in the `obj` Cayley graph.


image::nat-model.svg[width=450,align=center]

[exec,none="",exception=LanguageException]
----
:[model,social:('type' -> (nat    -> (nat<=int[is>0]), %
                           person -> (person:('name'->str,'age'->nat))))<=mm] //<1>
53 => [as,nat]                                                                //<2>
0  => [as,nat]
('name'->'marko','age'->29)  => [as,person]                                   //<3>
('name'->'marko','age'->-29) => [as,person]                                   //<4>
----
<1> a `social` model-ADT has `nat` and `person` type definition and a domain of `mm`.
<2> The `[model]` instruction is the first `inst` off the root of the `obj` graph.
<3> The `rec` is mapped to a `person` with the `age` value being mapped accordingly.
<4> The `rec` does not have an `age` value that maps to `nat` so the `rec` is not a `person`.